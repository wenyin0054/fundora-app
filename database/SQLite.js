import { DeviceEventEmitter } from "react-native";
import { Alert } from "react-native";
import { openDatabaseSync } from "expo-sqlite";

const db = openDatabaseSync('fundora.db', { location: 'default' });

// ------------------- DATABASE INITIALIZATION -------------------
export const initDB = async () => {
  try {
    console.log("âš™ï¸ Initializing Fundora database...");

    // ðŸ‘¤ Create Users Table
    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS users (
        userId TEXT PRIMARY KEY,
        username TEXT UNIQUE,
        email TEXT UNIQUE,
        created_at TEXT DEFAULT (datetime('now'))
      );
    `);

    // ðŸ§¾ Create User Summary Table
    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS user_summary (
        userId TEXT PRIMARY KEY,
        total_income REAL DEFAULT 0,
        total_expense REAL DEFAULT 0,
        total_balance REAL DEFAULT 0,
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // ðŸ§¾ Create Expenses Table
    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS expenses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        payee TEXT,
        amount REAL,
        date TEXT,
        tag TEXT,
        eventTag TEXT,
        paymentType TEXT,
        isPeriodic INTEGER,
        type TEXT,
        typeLabel TEXT,
        essentialityLabel INTEGER,
        goalId INTEGER,
        periodInterval INTEGER DEFAULT 0,
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // ðŸ¦ Create Goals Table
    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS goals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        goalName TEXT,
        description TEXT,
        targetAmount REAL,
        currentAmount REAL,
        deadline TEXT,
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // ðŸ·ï¸ Create Tags Table
    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS tags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        name TEXT UNIQUE,
        essentialityLabel INTEGER,
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // ðŸ·ï¸ Create Event Tags Table
    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS eventTags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        name TEXT UNIQUE,
        description TEXT,
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS activeEventTags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        eventTagId INTEGER,
        startDate TEXT,
        endDate TEXT,
        FOREIGN KEY (userId) REFERENCES users(userId),
        FOREIGN KEY (eventTagId) REFERENCES eventTags(id)
      );
    `);

    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS bills (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        billName TEXT,
        category TEXT,
        amount REAL,
        dueDate TEXT,
        status TEXT DEFAULT 'Upcoming',
        isAutoGenerated INTEGER DEFAULT 0,
        isCommitment INTEGER DEFAULT 0,
        periodType TEXT DEFAULT 'Yearly',
        periodInterval INTEGER DEFAULT 0,
        createdAt TEXT DEFAULT (date('now')),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS reminders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        billId INTEGER,
        userId TEXT,
        message TEXT,
        reminderDate TEXT,
        status TEXT DEFAULT 'Active',
        createdAt TEXT DEFAULT (date('now')),
        FOREIGN KEY (userId) REFERENCES users(userId),
        FOREIGN KEY (billId) REFERENCES bills(id)
      );
    `);

    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS predictor_cache (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        payee_normalized TEXT NOT NULL,
        tag TEXT NOT NULL,
        count INTEGER DEFAULT 1,
        confidence REAL DEFAULT 1.0,
        last_used INTEGER DEFAULT (strftime('%s','now')),
        is_custom INTEGER DEFAULT 0,
        UNIQUE(user_id, payee_normalized),
        FOREIGN KEY (user_id) REFERENCES users(userId)
      );
    `);

    // åœ¨ initDB() å‡½æ•¸ä¸­æ·»åŠ ä»¥ä¸‹è¡¨ï¼š

    // 1. å„²è“„æ–¹å¼é¡žåž‹è¡¨
    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS saving_methods (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        method_name TEXT,
        method_type TEXT,
        risk_level INTEGER,
        liquidity_level INTEGER,
        expected_return REAL,
        color_code TEXT,
        icon_name TEXT,
        is_default INTEGER DEFAULT 0,  -- 0: custom, 1: default
        UNIQUE(userId, method_name),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // 2. å…·é«”è³¬æˆ¶è¡¨
    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS saving_accounts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        method_id INTEGER,
        account_name TEXT,
        institution_name TEXT,
        account_number TEXT,
        current_balance REAL DEFAULT 0,
        interest_rate REAL,
        maturity_date TEXT,
        notes TEXT,
        FOREIGN KEY (method_id) REFERENCES saving_methods(id),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // 3. ç›®æ¨™è³‡é‡‘åˆ†é…è¡¨ (æ ¸å¿ƒ!)
    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS goal_fund_allocations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        goalId INTEGER,
        account_id INTEGER,
        allocated_amount REAL,
        allocation_date TEXT,
        transaction_id INTEGER,
        maturity_date TEXT,
        current_value REAL,
        expected_value REAL,
        status TEXT DEFAULT 'active', -- active, matured, withdrawn, reinvested
        notes TEXT,
        FOREIGN KEY (goalId) REFERENCES goals(id),
        FOREIGN KEY (account_id) REFERENCES saving_accounts(id),
        FOREIGN KEY (transaction_id) REFERENCES expenses(id),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS withdrawal_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        goalId INTEGER,
        allocation_id INTEGER,
        withdrawal_amount REAL,
        principal_amount REAL,
        interest_amount REAL,
        withdrawal_date TEXT DEFAULT (datetime('now')),
        status TEXT DEFAULT 'pending', -- pending, completed, cancelled
        confirmed_amount REAL,
        confirmed_date TEXT,
        notes TEXT,
        FOREIGN KEY (goalId) REFERENCES goals(id),
        FOREIGN KEY (allocation_id) REFERENCES goal_fund_allocations(id),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // Add new columns if not exist
    try {
      await db.execAsync(`ALTER TABLE bills ADD COLUMN periodType TEXT DEFAULT 'Yearly';`);
      console.log("âœ… Added periodType column to bills table");
    } catch (error) {
      if (!error.message.includes("duplicate column")) {
        console.error(error);
      }
    }

    try {
      await db.execAsync(`ALTER TABLE bills ADD COLUMN periodInterval INTEGER DEFAULT 0;`);
      console.log("âœ… Added periodInterval column to bills table");
    } catch (error) {
      if (!error.message.includes("duplicate column")) {
        console.error(error);
      }
    }

    console.log("âœ… All database tables are ready with user isolation");
  } catch (error) {
    console.error("âŒ initDB error:", error);
  }
};

// ------------------- USER MANAGEMENT -------------------
export const createUser = async (userId, username = null, email = null) => {
  try {
    await db.runAsync(
      `INSERT OR IGNORE INTO users (userId, username, email) VALUES (?, ?, ?)`,
      [userId, username, email]
    );
    console.log(`âœ… User ${userId} created/verified`);
  } catch (error) {
    console.error("âŒ createUser error:", error);
  }
};

// ------------------- USER SUMMARY TABLE -------------------
export const createUserSummary = async (userId) => {
  await db.runAsync(
    `INSERT OR IGNORE INTO user_summary (userId, total_income, total_expense, total_balance)
     VALUES (?, 0, 0, 0)`,
    [userId]
  );
};

export const getUserSummary = async (userId) => {
  const result = await db.getFirstAsync(
    `SELECT total_income, total_expense, total_balance FROM user_summary WHERE userId = ?`,
    [userId]
  );
  return result || { total_income: 0, total_expense: 0, total_balance: 0 };
};

export const updateUserSummary = async (userId, type, amount) => {
  console.log("Updating user summary:", { userId, type, amount });

  if (type === "income") {
    await db.runAsync(
      `UPDATE user_summary 
       SET total_income = total_income + ?, 
           total_balance = total_balance + ? 
       WHERE userId = ?`,
      [amount, amount, userId]
    );
  } else if (type === "expense") {
    await db.runAsync(
      `UPDATE user_summary 
       SET total_expense = total_expense + ?, 
           total_balance = total_balance - ? 
       WHERE userId = ?`,
      [amount, amount, userId]
    );
  }

  const summary = await getUserSummary(userId);
  console.log("ðŸ“Š Updated user summary:", summary);
};

export const resetUserSummary = async (userId) => {
  await db.runAsync(
    `UPDATE user_summary 
     SET total_income = 0, total_expense = 0, total_balance = 0 
     WHERE userId = ?`,
    [userId]
  );
};

export const updateUserSummaryOnAdd = async (userId, type, amount) => {
  try {
    const amountNum = parseFloat(amount);

    const summary = await getUserSummary(userId);
    const currentExpense = summary.total_expense || 0;
    const currentIncome = summary.total_income || 0;
    const currentBalance = summary.total_balance || 0;

    let newExpense = currentExpense;
    let newIncome = currentIncome;
    let newBalance = currentBalance;

    if (type === "expense") {
      newExpense = currentExpense + amountNum;
      newBalance = currentBalance - amountNum;
    } else if (type === "income") {
      newIncome = currentIncome + amountNum;
      newBalance = currentBalance + amountNum;
    }

    const results = await db.runAsync(
      `UPDATE user_summary SET total_expense = ?, total_income = ?, total_balance = ? WHERE userId = ?`,
      [newExpense, newIncome, newBalance, userId]
    );

    console.log(`âœ… Summary updated - Expense: ${currentExpense}->${newExpense}, Income: ${currentIncome}->${newIncome}, Balance: ${currentBalance}->${newBalance}`);
    return results;
  } catch (error) {
    console.error(`âŒ Error adding to summary:`, error);
    throw error;
  }
};

export const updateUserSummaryOnEdit = async (userId, type, oldAmount, newAmount) => {
  try {
    const oldAmountNum = parseFloat(oldAmount);
    const newAmountNum = parseFloat(newAmount);
    const diff = newAmountNum - oldAmountNum;

    const summary = await getUserSummary(userId);
    const currentExpense = summary.total_expense || 0;
    const currentIncome = summary.total_income || 0;
    const currentBalance = summary.total_balance || 0;

    let newExpense = currentExpense;
    let newIncome = currentIncome;
    let newBalance = currentBalance;

    if (type === "expense") {
      newExpense = currentExpense + diff;
      newBalance = currentBalance - diff;
    } else if (type === "income") {
      newIncome = currentIncome + diff;
      newBalance = currentBalance + diff;
    }

    const results = await db.runAsync(
      `UPDATE user_summary SET total_expense = ?, total_income = ?, total_balance = ? WHERE userId = ?`,
      [newExpense, newIncome, newBalance, userId]
    );

    console.log(`âœ… Summary edited - Expense: ${currentExpense}->${newExpense}, Income: ${currentIncome}->${newIncome}, Balance: ${currentBalance}->${newBalance}`);
    return results;
  } catch (error) {
    console.error(`âŒ Error editing summary:`, error);
    throw error;
  }
};

export const updateUserSummaryOnDelete = async (userId, type, amount) => {
  try {
    const amountNum = parseFloat(amount);

    const summary = await getUserSummary(userId);
    const currentExpense = summary.total_expense || 0;
    const currentIncome = summary.total_income || 0;
    const currentBalance = summary.total_balance || 0;

    let newExpense = currentExpense;
    let newIncome = currentIncome;
    let newBalance = currentBalance;

    if (type === "expense") {
      newExpense = currentExpense - amountNum;
      newBalance = currentBalance + amountNum;
    } else if (type === "income") {
      newIncome = currentIncome - amountNum;
      newBalance = currentBalance - amountNum;
    }

    const results = await db.runAsync(
      `UPDATE user_summary SET total_expense = ?, total_income = ?, total_balance = ? WHERE userId = ?`,
      [newExpense, newIncome, newBalance, userId]
    );

    console.log(`âœ… Summary deleted - Expense: ${currentExpense}->${newExpense}, Income: ${currentIncome}->${newIncome}, Balance: ${currentBalance}->${newBalance}`);
    return results;
  } catch (error) {
    console.error(`âŒ Error deleting from summary:`, error);
    throw error;
  }
};

// -------------------- EXPENSES CRUD -------------------
export const addExpenseLocal = async (
  userId,
  payee,
  amount,
  date,
  tag,
  eventTag,
  paymentType,
  isPeriodic,
  type,
  typeLabel,
  essentialityLabel,
  goalId,
  periodInterval = 0
) => {
  try {
    await db.runAsync(
      `INSERT INTO expenses (
      userId, payee, amount, date, tag, eventTag,
      paymentType, isPeriodic, type, typeLabel,
      essentialityLabel, goalId, periodInterval
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        userId,
        payee,
        amount,
        date,
        tag,
        eventTag,
        paymentType,
        isPeriodic ? 1 : 0,
        type,
        typeLabel,
        essentialityLabel,
        goalId,
        periodInterval
      ]
    );

    console.log("âœ… Expense added successfully:", typeLabel);
    console.log("ðŸ§¾ Added Detail:", {
      userId, payee, amount, date, tag, eventTag, paymentType,
      isPeriodic, typeLabel, essentialityLabel, goalId, periodInterval
    });
  } catch (error) {
    console.error("âŒ addExpenseLocal error:", error);
  }
};

// Get all expenses for a specific user
export const getExpensesLocal = async (userId) => {
  try {
    const results = await db.getAllAsync(
      `SELECT * FROM expenses WHERE userId = ? ORDER BY date DESC;`,
      [userId]
    );
    const normalized = results.map(item => ({
      ...item,
      amount: parseFloat(item.amount) || 0,
      essentialityLabel: Number(item.essentialityLabel),
      isPeriodic: Number(item.isPeriodic),
      periodInterval: Number(item.periodInterval) || 1,
    }));
    return normalized;
  } catch (error) {
    console.error("âŒ getExpensesLocal error:", error);
    return [];
  }
};
export const getTotalExpensesLocal = async (userId) => {
  try {
    const result = await db.getFirstAsync(
      `SELECT total_expense FROM user_summary WHERE userId = ?`,
      [userId]
    );

    return result?.total_expense || 0;
  } catch (error) {
    console.error("âŒ getTotalExpensesLocal error:", error);
    return 0;
  }
};


// Delete expense by ID (ä¿æŒåŽŸæœ‰åŠŸèƒ½ï¼Œä½†ç¢ºä¿åªèƒ½åˆªé™¤è©²ç”¨æˆ¶çš„è³‡æ–™)
export const deleteExpenseLocal = async (userId, id) => {
  try {
    await db.runAsync(`DELETE FROM expenses WHERE id = ? AND userId = ?;`, [id, userId]);
    console.log(`ðŸ—‘ï¸ Expense with ID ${id} deleted for user ${userId}`);
  } catch (error) {
    console.error("âŒ deleteExpenseLocal error:", error);
  }
};

// Update expense
export const updateExpenseLocal = async (
  userId,
  id,
  payee,
  amount,
  date,
  tag,
  eventTag,
  paymentType,
  isPeriodic,
  type,
  typeLabel,
  essentialityLabel,
  goalId,
  periodInterval
) => {
  try {
    await db.runAsync(
      `UPDATE expenses
       SET 
         payee = ?, 
         amount = ?, 
         date = ?, 
         tag = ?, 
         eventTag = ?, 
         paymentType = ?, 
         isPeriodic = ?, 
         type = ?, 
         typeLabel = ?, 
         essentialityLabel = ?, 
         goalId = ?, 
         periodInterval = ?
       WHERE id = ? AND userId = ?;`,
      [
        payee,
        amount,
        date,
        tag,
        eventTag,
        paymentType,
        isPeriodic ? 1 : 0,
        type,
        typeLabel,
        essentialityLabel ?? 0,
        goalId ?? null,
        periodInterval ?? 0,
        id,
        userId
      ]
    );

    console.log(`âœ… Expense record updated successfully (ID: ${id}) for user ${userId}`);
  } catch (error) {
    console.error("âŒ Error updating expense in local database:", error);
  }
};

export const getExpensesByTypeLabelLocal = async (userId, typeLabel) => {
  try {
    if (!db || !db.getAllAsync) {
      throw new Error("âŒ DB is not initialized or missing getAllAsync method");
    }

    const allowedTypes = ["income", "expenses", "transaction"];
    if (!allowedTypes.includes(typeLabel)) {
      throw new Error(`âŒ Invalid typeLabel: ${typeLabel}`);
    }

    const results = await db.getAllAsync(
      `SELECT * FROM expenses WHERE userId = ? AND typeLabel = ? ORDER BY date DESC`,
      [userId, typeLabel]
    );

    console.log(`âœ… Fetched ${results.length} rows for typeLabel: ${typeLabel} for user ${userId}`);
    return results;
  } catch (error) {
    console.error("âŒ getExpensesByTypeLabelLocal error:", error);
    return [];
  }
};

export const clearAllExpensesLocal = async (userId) => {
  try {
    await db.runAsync(`DELETE FROM expenses WHERE userId = ?;`, [userId]);
    console.log(`ðŸ—‘ï¸ All expenses cleared for user ${userId}`);
  } catch (error) {
    console.error("âŒ clearAllExpensesLocal error:", error);
  }
};


// ðŸ§® Get total and essential total expenses for last month for specific user
export const getLastMonthTotalExpense = async (userId) => {
  try {
    const results = await db.getAllAsync(
      `SELECT
        SUM(amount) AS total,
        SUM(CASE WHEN essentialityLabel = 1 THEN amount ELSE 0 END) AS essentialTotal
      FROM expenses
      WHERE userId = ? AND strftime('%Y-%m', date) = strftime('%Y-%m', 'now', '-1 month');`,
      [userId]
    );

    const row = results?.[0] || {};
    const total = parseFloat(row.total) || 0;
    const essentialTotal = parseFloat(row.essentialTotal) || 0;

    console.log("âœ… Last month expenses for user", userId, ":", { total, essentialTotal });
    return { total, essentialTotal };
  } catch (error) {
    console.error("âŒ getLastMonthTotalExpense error:", error);
    return { total: 0, essentialTotal: 0 };
  }
};

// ------------------- GOALS CRUD -------------------
export const createGoalTable = async (userId) => {
  await db.execAsync(`
    DROP TABLE IF EXISTS goals;
  `);
  await db.execAsync(`
    CREATE TABLE IF NOT EXISTS goals (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      userId TEXT,
      goalName TEXT,
      description TEXT,
      targetAmount REAL,
      currentAmount REAL,
      deadline TEXT,
      FOREIGN KEY (userId) REFERENCES users(userId)
    );
  `);
};

export const addGoalLocal = async (userId, goalName, description, targetAmount, currentAmount, deadline) => {
  await db.runAsync(
    `INSERT INTO goals (userId, goalName, description, targetAmount, currentAmount, deadline)
     VALUES (?, ?, ?, ?, ?, ?);`,
    [userId, goalName, description, targetAmount, currentAmount, deadline]
  );
};

export const getGoalsLocal = async (userId) => {
  return await db.getAllAsync(
    `SELECT * FROM goals WHERE userId = ? ORDER BY deadline ASC;`,
    [userId]
  );
};

export const updateGoalLocal = async (userId, id, goalName, description, targetAmount, currentAmount, deadline) => {
  try {
    await db.runAsync(
      `UPDATE goals
       SET goalName = ?, description = ?, targetAmount = ?, currentAmount = ?, deadline = ?
       WHERE id = ? AND userId = ?;`,
      [goalName, description, targetAmount, currentAmount, deadline, id, userId]
    );
    console.log(`âœ… Goal ID ${id} updated for user ${userId}`);
  } catch (error) {
    console.error("âŒ updateGoalLocal error:", error);
  }
};

export const deleteGoalLocal = async (userId, id) => {
  try {
    await db.runAsync(`DELETE FROM goals WHERE id = ? AND userId = ?;`, [id, userId]);
    console.log(`ðŸ—‘ï¸ Goal ID ${id} deleted for user ${userId}`);
  } catch (error) {
    console.error("âŒ deleteGoalLocal error:", error);
  }
};

export const deleteAllGoals = async () => {
  try {
    await db.runAsync(`DELETE FROM goals;`);
    console.log("ðŸ—‘ï¸ All goals deleted successfully");
  } catch (error) {
    console.error("âŒ deleteAllGoals error:", error);
  }
};


// Update currentAmount of a goal by adding amount
export const updateGoalAmount = async (userId, goalId, amount) => {
  try {
    await db.runAsync(
      `UPDATE goals 
       SET currentAmount = currentAmount + ? 
       WHERE id = ? AND userId = ?`,
      [amount, goalId, userId]
    );
    console.log(`âœ… Goal ${goalId} updated by ${amount} for user ${userId}`);
  } catch (error) {
    console.error("âŒ Error updating goal amount:", error);
  }
};

// ------------------- TAGS CRUD -------------------
export const createTagTable = async () => {
  await db.execAsync(`
    CREATE TABLE IF NOT EXISTS tags (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      userId TEXT,
      name TEXT UNIQUE,
      essentialityLabel INTEGER,
      FOREIGN KEY (userId) REFERENCES users(userId)
    );
  `);
};

export const addTagLocal = async (userId, name, essentialityLabel) => {
  await db.runAsync(
    `INSERT INTO tags (userId, name, essentialityLabel)
     VALUES (?, ?, ?);`,
    [userId, name, essentialityLabel]
  );
};

export const getTagsLocal = async (userId) => {
  return await db.getAllAsync(
    `SELECT * FROM tags WHERE userId = ? ORDER BY name ASC;`,
    [userId]
  );
};

export const deleteTagLocal = async (userId, id) => {
  try {
    await db.runAsync(`DELETE FROM tags WHERE id = ? AND userId = ?;`, [id, userId]);
    console.log(`ðŸ—‘ï¸ Tag ID ${id} deleted for user ${userId}`);
  } catch (error) {
    console.error("âŒ deleteTagLocal error:", error);
  }
};

// ------------------- EVENT TAGS CRUD -------------------
export const createEventTagTable = async () => {
  await db.execAsync(`
    CREATE TABLE IF NOT EXISTS eventTags (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      userId TEXT,
      name TEXT UNIQUE,
      description TEXT,
      FOREIGN KEY (userId) REFERENCES users(userId)
    );
  `);
  console.log("âœ… eventTags table ready");
};

export const addEventTagLocal = async (userId, name, description = null) => {
  try {
    await db.runAsync(
      `INSERT INTO eventTags (userId, name, description)
       VALUES (?, ?, ?);`,
      [userId, name, description]
    );
    console.log(`âœ… Event tag '${name}' added for user ${userId}`);
    DeviceEventEmitter.emit("eventTagsUpdated");
    return true; // âœ… æ·»åŠ é€™è¡Œ
  } catch (error) {
    if (error.message.includes("UNIQUE constraint failed")) {
      console.warn(`âš ï¸ Event tag '${name}' already exists for user ${userId}`);
      return false; // âœ… æ·»åŠ é€™è¡Œ
    } else {
      console.error("âŒ addEventTagLocal error:", error);
      return false; // âœ… æ·»åŠ é€™è¡Œ
    }
  }
};
export const getEventTagsLocal = async (userId) => {
  try {
    const results = await db.getAllAsync(
      `SELECT * FROM eventTags WHERE userId = ? ORDER BY name ASC;`,
      [userId]
    );
    console.log(`âœ… Retrieved ${results.length} event tags for user ${userId}`);
    return results;
  } catch (error) {
    console.error("âŒ getEventTagsLocal error:", error);
    return [];
  }
};

export const updateEventTagLocal = async (userId, id, newName, newDescription) => {
  try {
    await db.runAsync(
      `UPDATE eventTags
       SET name = ?, description = ?
       WHERE id = ? AND userId = ?;`,
      [newName, newDescription, id, userId]
    );
    console.log(`âœ… Event tag ID ${id} updated for user ${userId}`);
    DeviceEventEmitter.emit("eventTagsUpdated");
  } catch (error) {
    console.error("âŒ updateEventTagLocal error:", error);
  }
};

export const deleteEventTagLocal = async (userId, id) => {
  try {
    await db.runAsync(`DELETE FROM eventTags WHERE id = ? AND userId = ?;`, [id, userId]);
    console.log(`ðŸ—‘ï¸ Event tag ID ${id} deleted for user ${userId}`);
    DeviceEventEmitter.emit("eventTagsUpdated");
  } catch (error) {
    console.error("âŒ deleteEventTagLocal error:", error);
  }
};

// ------------------- ACTIVE EVENT TAGS CRUD -------------------
export const addActiveEventTagLocal = async (userId, eventTagId, startDate, endDate) => {
  try {
    await db.runAsync(
      `INSERT INTO activeEventTags (userId, eventTagId, startDate, endDate) VALUES (?, ?, ?, ?);`,
      [userId, eventTagId, startDate, endDate]
    );
    console.log(`âœ… Active event tag added for user ${userId}`);
  } catch (error) {
    console.error("âŒ addActiveEventTagLocal error:", error);
  }
};

export const getActiveEventTagsLocal = async (userId) => {
  try {
    const results = await db.getAllAsync(
      `SELECT aet.id, aet.startDate, aet.endDate, et.name 
       FROM activeEventTags aet
       JOIN eventTags et ON aet.eventTagId = et.id
       WHERE aet.userId = ?
       ORDER BY aet.startDate DESC;`,
      [userId]
    );
    return results;
  } catch (error) {
    console.error("âŒ getActiveEventTagsLocal error:", error);
    return [];
  }
};

export const deleteActiveEventTagLocal = async (userId, id) => {
  try {
    await db.runAsync(`DELETE FROM activeEventTags WHERE id = ? AND userId = ?;`, [id, userId]);
    console.log(`ðŸ—‘ï¸ Active event tag ID ${id} deleted for user ${userId}`);
  } catch (error) {
    console.error("âŒ deleteActiveEventTagLocal error:", error);
  }
};

export const clearAllActiveEventTagsLocal = async (userId) => {
  try {
    await db.runAsync(
      `DELETE FROM activeEventTags WHERE userId = ?;`,
      [userId]
    );
    console.log(`ðŸ—‘ï¸ All active event tags for user ${userId} cleared`);
  } catch (error) {
    console.error("âŒ clearAllActiveEventTagsLocal error:", error);
  }
};

// ------------------- Bills CRUD -------------------
export const addBillLocal = async ({
  userId,
  billName,
  category = "",
  amount = 0,
  dueDate,
  isAutoGenerated = 0,
  isCommitment = 0,
  periodType = "Yearly",
  periodInterval = 0,
}) => {
  try {
    await db.runAsync(
      `INSERT INTO bills 
        (userId, billName, category, amount, dueDate, isAutoGenerated, isCommitment, periodType, periodInterval)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);`,
      [
        userId,
        billName,
        category,
        amount,
        dueDate,
        isAutoGenerated ? 1 : 0,
        isCommitment ? 1 : 0,
        periodType,
        periodInterval,
      ]
    );
    return true;
  } catch (err) {
    console.error("âŒ addBillLocal error:", err);
    throw err;
  }
};

export const getBillsLocal = async (userId) => {
  try {
    const results = await db.getAllAsync(
      `SELECT * FROM bills WHERE userId = ? ORDER BY dueDate ASC;`,
      [userId]
    );

    return results.map(r => ({
      ...r,
      amount: parseFloat(r.amount) || 0,
      isAutoGenerated: Number(r.isAutoGenerated || 0),
      isCommitment: Number(r.isCommitment || 0),
      periodType: r.periodType || "Yearly",
      periodInterval: Number(r.periodInterval || 0),
    }));
  } catch (err) {
    console.error("âŒ getBillsLocal error:", err);
    return [];
  }
};

export const getPeriodicBillsLocal = async (userId) => {
  try {
    const results = await db.getAllAsync(
      `SELECT * FROM bills WHERE userId = ? AND isAutoGenerated = 1 ORDER BY dueDate ASC;`,
      [userId]
    );

    return results.map(r => ({
      ...r,
      amount: parseFloat(r.amount) || 0,
      isAutoGenerated: Number(r.isAutoGenerated || 0),
      isCommitment: Number(r.isCommitment || 0),
      periodType: r.periodType || "Yearly",
      periodInterval: Number(r.periodInterval || 1),
      isPeriodic: Number(r.isPeriodic || 0),
    }));
  } catch (err) {
    console.error("âŒ getPeriodicBillsLocal error:", err);
    return [];
  }
};

export const getAutoGeneratedBillsLocal = async (userId) => {
  try {
    const results = await db.getAllAsync(
      `SELECT * FROM bills WHERE userId = ? AND isAutoGenerated = 1 ORDER BY dueDate ASC;`,
      [userId]
    );

    return results.map(r => ({
      ...r,
      amount: parseFloat(r.amount) || 0,
      isAutoGenerated: Number(r.isAutoGenerated || 0),
      isCommitment: Number(r.isCommitment || 0),
      periodType: r.periodType || "Yearly",
      periodInterval: Number(r.periodInterval || 0),
    }));
  } catch (err) {
    console.error("âŒ getAutoGeneratedBillsLocal error:", err);
    return [];
  }
};

export const updateBillLocal = async (userId, id, fields = {}) => {
  try {
    const setters = [];
    const values = [];

    for (const [k, v] of Object.entries(fields)) {
      setters.push(`${k} = ?`);
      values.push(v);
    }

    if (setters.length === 0) return;

    values.push(id);
    values.push(userId);

    const sql = `UPDATE bills SET ${setters.join(", ")} WHERE id = ? AND userId = ?;`;
    await db.runAsync(sql, values);

    return true;
  } catch (err) {
    console.error("âŒ updateBillLocal error:", err);
    throw err;
  }
};

export const deleteBillLocal = async (userId, id) => {
  try {
    await db.runAsync(`DELETE FROM reminders WHERE billId = ?;`, [id]);
    await db.runAsync(`DELETE FROM bills WHERE id = ? AND userId = ?;`, [id, userId]);
    return true;
  } catch (err) {
    console.error("âŒ deleteBillLocal error:", err);
    throw err;
  }
};

// ------------------- reminder CRUD -------------------
export const getRemindersLocal = async (userId, limit = 5) => {
  try {
    const results = await db.getAllAsync(
      `SELECT r.*, b.billName, b.dueDate
       FROM reminders r
       LEFT JOIN bills b ON r.billId = b.id
       WHERE r.userId = ? AND r.status = 'Active'
       ORDER BY r.reminderDate ASC
       LIMIT ?;`,
      [userId, limit]
    );
    return results.map(r => ({ ...r }));
  } catch (err) {
    console.error("âŒ getRemindersLocal error:", err);
    return [];
  }
};

export const deleteReminderLocal = async (userId, id) => {
  try {
    await db.runAsync(
      `DELETE FROM reminders WHERE id = ? AND userId = ?;`,
      [id, userId]
    );
    console.log(`ðŸ—‘ï¸ Reminder ID ${id} deleted for user ${userId}`);
  } catch (err) {
    console.error("âŒ deleteReminderLocal error:", err);
  }
};

export const checkDueBillsAndGenerateReminders = async (userId) => {
  try {
    const bills = await getBillsLocal(userId);
    if (!bills || bills.length === 0) return;

    const today = new Date();
    const todayStr = today.toISOString().split("T")[0];
    const todayStart = new Date(todayStr + "T00:00:00");

    const reminderMessages = [];

    for (const b of bills) {
      try {
        if (!b.dueDate) continue;

        const dueDateStr = b.dueDate;
        const due = new Date(dueDateStr + "T00:00:00");

        const msPerDay = 1000 * 60 * 60 * 24;
        const daysDiff = Math.floor((due - todayStart) / msPerDay);

        let newStatus = "Upcoming";
        if (daysDiff < 0) newStatus = "Overdue";
        else if (daysDiff <= 3) newStatus = "DueSoon";

        if (newStatus !== b.status) {
          await updateBillLocal(userId, b.id, { status: newStatus });
        }

        let reminderDate = null;
        if (newStatus === "Overdue") reminderDate = todayStr;
        else if (newStatus === "DueSoon") reminderDate = dueDateStr;

        if ((newStatus === "Overdue" || newStatus === "DueSoon") && reminderDate) {
          const existing = await db.getFirstAsync(
            `SELECT id FROM reminders WHERE billId = ? AND reminderDate = ? AND status = 'Active' LIMIT 1;`,
            [b.id, reminderDate]
          );

          if (!existing) {
            const message =
              newStatus === "Overdue"
                ? `â— ${b.billName} is overdue.`
                : `â³ ${b.billName} is due in ${Math.max(0, daysDiff)} day(s).`;

            const createdAtDate = todayStr;

            await db.runAsync(
              `INSERT INTO reminders (billId, userId, message, reminderDate, status, createdAt)
               VALUES (?, ?, ?, ?, 'Active', ?);`,
              [b.id, userId, message, reminderDate, createdAtDate]
            );

            reminderMessages.push(message);
          }
        }
      } catch (innerErr) {
        console.error("Error processing bill:", b.id, innerErr);
      }
    }

    if (reminderMessages.length > 0) {
      const alertText = reminderMessages.join("\n");

      Alert.alert(
        "ðŸ”” Bill Reminders",
        alertText + "\n\nPlease settle them soon.",
        [{ text: "OK" }]
      );
    }

  } catch (err) {
    console.error("âŒ checkDueBillsAndGenerateReminders error:", err);
  }
};

export const getMonthlyDebtSum = async (userId) => {
  try {
    const rows = await db.getAllAsync(
      `SELECT amount, category FROM bills WHERE userId = ? AND status != 'Paid';`,
      [userId]
    );
    let sum = 0;
    for (const r of rows) {
      const cat = (r.category || "").toLowerCase();
      if (cat.includes("debt") || cat.includes("credit") || cat.includes("loan") || cat.includes("debt")) {
        sum += parseFloat(r.amount || 0);
      }
    }
    return sum;
  } catch (err) {
    console.error("âŒ getMonthlyDebtSum error:", err);
    return 0;
  }
};

// ------------------- AUTO TAG PREDICTOR FUNCTIONS -------------------
export async function getUserTag(userId, payee) {
  const norm = normalize(payee);
  console.log("ðŸ” getUserTag DEBUG:", {
    userId,
    payee,
    normalized: norm,
    normalizedLength: norm.length
  });

  try {
    const row = await db.getFirstAsync(
      `SELECT tag, confidence, count 
       FROM predictor_cache 
       WHERE payee_normalized = ? AND user_id = ?
       LIMIT 1;`,
      [norm, userId]
    );

    console.log("ðŸ” getUserTag RESULT:", row);
    return row ?? null;
  } catch (err) {
    console.error("âŒ getUserTag error:", err);
    return null;
  }
}

export async function saveUserTag(userId, payee, tag, is_custom = 0) {
  const norm = normalize(payee);
  const ts = Math.floor(Date.now() / 1000);

  try {
    const existing = await db.getFirstAsync(
      `SELECT * FROM predictor_cache WHERE payee_normalized = ? AND user_id = ?;`,
      [norm, userId]
    );

    if (existing) {
      await db.runAsync(
        `UPDATE predictor_cache 
         SET tag = ?, 
             count = count + 1,
             confidence = MIN(1.0, confidence + 0.05),
             last_used = ?,
             is_custom = ?
         WHERE payee_normalized = ? AND user_id = ?;`,
        [tag, ts, is_custom, norm, userId]
      );
      console.log(`âœ… Updated tag for "${payee}" -> "${tag}"`);
    } else {
      await db.runAsync(
        `INSERT INTO predictor_cache 
         (user_id, payee_normalized, tag, count, confidence, last_used, is_custom)
         VALUES (?, ?, ?, 1, 1.0, ?, ?);`,
        [userId, norm, tag, ts, is_custom]
      );
      console.log(`âœ… Saved new tag for "${payee}" -> "${tag}"`);
    }

    return true;
  } catch (err) {
    console.error("saveUserTag error:", err);
    return false;
  }
}

export async function getUserPredictions(userId) {
  try {
    const rows = await db.getAllAsync(
      `SELECT * FROM predictor_cache WHERE user_id = ? ORDER BY last_used DESC;`,
      [userId]
    );
    return rows;
  } catch (err) {
    console.error("getUserPredictions error:", err);
    return [];
  }
}

export async function clearUserPredictions(userId) {
  try {
    await db.runAsync(
      `DELETE FROM predictor_cache WHERE user_id = ?;`,
      [userId]
    );
    console.log(`âœ… Cleared predictions for user ${userId}`);
    return true;
  } catch (err) {
    console.error("clearUserPredictions error:", err);
    return false;
  }
}

// Normalize function
function normalize(payee) {
  if (!payee) return '';
  return payee
    .toLowerCase()
    .trim()
    .replace(/[^\w\s]/g, '')
    .replace(/\s+/g, ' ');
}

// ------------------- SAVING METHODS & ACCOUNTS -------------------

// åˆå§‹åŒ–é è¨­å„²è“„æ–¹å¼
export const initDefaultSavingMethods = async (userId) => {
  const defaultMethods = [
    { method_name: "Fixed Deposit", method_type: "bank", risk_level: 1, liquidity_level: 3, expected_return: 3.2, color_code: "#4CAF50", icon_name: "ðŸ¦",is_default: 1 },
    { method_name: "Gold Bar", method_type: "physical", risk_level: 2, liquidity_level: 2, expected_return: 5.0, color_code: "#FFD700", icon_name: "ðŸ¥‡",is_default: 1 },
    { method_name: "Unit Trust", method_type: "investment", risk_level: 3, liquidity_level: 4, expected_return: 8.0, color_code: "#2196F3", icon_name: "ðŸ“ˆ",is_default: 1 },
    { method_name: "Stocks", method_type: "investment", risk_level: 4, liquidity_level: 5, expected_return: 12.0, color_code: "#FF9800", icon_name: "ðŸ“Š",is_default: 1 },
    { method_name: "Cash", method_type: "cash", risk_level: 1, liquidity_level: 5, expected_return: 0.0, color_code: "#9E9E9E", icon_name: "ðŸ’µ",is_default: 1 },
    { method_name: "Digital Gold", method_type: "digital", risk_level: 2, liquidity_level: 5, expected_return: 6.0, color_code: "#FFC107", icon_name: "ðŸ“±",is_default: 1 }
  ];

  for (const method of defaultMethods) {
    await db.runAsync(
      `INSERT OR IGNORE INTO saving_methods 
       (userId, method_name, method_type, risk_level, liquidity_level, expected_return, color_code, icon_name)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [userId, method.method_name, method.method_type, method.risk_level, 
       method.liquidity_level, method.expected_return, method.color_code, method.icon_name]
    );
  }
  console.log("âœ… Default saving methods initialized");
};

// å‰µå»ºå„²è“„è³¬æˆ¶
export const addSavingAccount = async (userId, method_id, account_name, institution_name, account_number, interest_rate, maturity_date, notes = "") => {
  await db.runAsync(
    `INSERT INTO saving_accounts 
     (userId, method_id, account_name, institution_name, account_number, interest_rate, maturity_date, notes)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
    [userId, method_id, account_name, institution_name, account_number, interest_rate, maturity_date, notes]
  );
};

// ç²å–å„²è“„æ–¹å¼
export const getSavingMethods = async (userId) => {
  return await db.getAllAsync(
    `SELECT * FROM saving_methods WHERE userId = ? ORDER BY method_name ASC;`,
    [userId]
  );
};

// ç²å–å„²è“„è³¬æˆ¶
export const getSavingAccounts = async (userId) => {
  return await db.getAllAsync(
    `SELECT sa.*, sm.method_name, sm.icon_name, sm.color_code
     FROM saving_accounts sa
     JOIN saving_methods sm ON sa.method_id = sm.id
     WHERE sa.userId = ? ORDER BY sa.account_name ASC;`,
    [userId]
  );
};

// ------------------- GOAL FUND ALLOCATION -------------------
// åœ¨ SQLite.js ä¸­æ·»åŠ é€™äº›å‡½æ•¸

// æ·»åŠ å„²è“„æ–¹å¼
export const addSavingMethod = async (userId, methodData) => {
  try {
    await db.runAsync(
      `INSERT INTO saving_methods 
       (userId, method_name, method_type, risk_level, liquidity_level, 
        expected_return, color_code, icon_name, is_default)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        userId,
        methodData.method_name,
        methodData.method_type,
        methodData.risk_level,
        methodData.liquidity_level,
        methodData.expected_return,
        methodData.color_code,
        methodData.icon_name,
        methodData.is_default || 0
      ]
    );
    console.log(`âœ… Saving method '${methodData.method_name}' added`);
    return true;
  } catch (error) {
    console.error("âŒ addSavingMethod error:", error);
    return false;
  }
};

// æ›´æ–°å„²è“„æ–¹å¼
export const updateSavingMethod = async (userId, methodId, methodData) => {
  try {
    await db.runAsync(
      `UPDATE saving_methods 
       SET method_name = ?, method_type = ?, risk_level = ?, liquidity_level = ?,
           expected_return = ?, color_code = ?, icon_name = ?
       WHERE id = ? AND userId = ? AND is_default = 0`,
      [
        methodData.method_name,
        methodData.method_type,
        methodData.risk_level,
        methodData.liquidity_level,
        methodData.expected_return,
        methodData.color_code,
        methodData.icon_name,
        methodId,
        userId
      ]
    );
    console.log(`âœ… Saving method ${methodId} updated`);
    return true;
  } catch (error) {
    console.error("âŒ updateSavingMethod error:", error);
    return false;
  }
};

// åˆªé™¤å„²è“„æ–¹å¼
export const deleteSavingMethod = async (userId, methodId) => {
  try {
    // æª¢æŸ¥æ˜¯å¦æœ‰è³¬æˆ¶ä½¿ç”¨é€™å€‹æ–¹æ³•
    const accounts = await db.getAllAsync(
      `SELECT id FROM saving_accounts WHERE method_id = ? AND userId = ?`,
      [methodId, userId]
    );
    
    if (accounts.length > 0) {
      throw new Error("Cannot delete method with existing accounts");
    }
    
    await db.runAsync(
      `DELETE FROM saving_methods WHERE id = ? AND userId = ? AND is_default = 0`,
      [methodId, userId]
    );
    console.log(`âœ… Saving method ${methodId} deleted`);
    return true;
  } catch (error) {
    console.error("âŒ deleteSavingMethod error:", error);
    throw error;
  }
};

// åˆ†é…è³‡é‡‘åˆ°å…·é«”è³¬æˆ¶
export const allocateFundToGoal = async (userId, goalId, account_id, allocated_amount, allocation_date, transaction_id, maturity_date, notes = "") => {
  try {
    // è¨ˆç®—é æœŸåƒ¹å€¼
    const account = await db.getFirstAsync(
      `SELECT interest_rate FROM saving_accounts WHERE id = ? AND userId = ?`,
      [account_id, userId]
    );
    
    const interest_rate = account?.interest_rate || 0;
    const expected_value = allocated_amount * (1 + interest_rate / 100);
    
    await db.runAsync(
      `INSERT INTO goal_fund_allocations 
       (userId, goalId, account_id, allocated_amount, allocation_date, transaction_id, maturity_date, current_value, expected_value, notes)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [userId, goalId, account_id, allocated_amount, allocation_date, transaction_id, 
       maturity_date, allocated_amount, expected_value, notes]
    );
    
    // æ›´æ–°è³¬æˆ¶é¤˜é¡
    await db.runAsync(
      `UPDATE saving_accounts SET current_balance = current_balance + ? WHERE id = ? AND userId = ?`,
      [allocated_amount, account_id, userId]
    );
    
    console.log(`âœ… Fund allocated to goal: ${allocated_amount} to account ${account_id}`);
  } catch (error) {
    console.error("âŒ allocateFundToGoal error:", error);
    throw error;
  }
};

// ç²å–ç›®æ¨™çš„è³‡é‡‘åˆ†é…è©³æƒ…
export const getGoalFundAllocations = async (userId, goalId) => {
  return await db.getAllAsync(
    `SELECT gfa.*, 
            sa.account_name, 
            sa.institution_name, 
            sa.interest_rate,  
            sa.maturity_date,
            sm.method_name, 
            sm.icon_name, 
            sm.color_code
     FROM goal_fund_allocations gfa
     JOIN saving_accounts sa ON gfa.account_id = sa.id
     JOIN saving_methods sm ON sa.method_id = sm.id
     WHERE gfa.userId = ? AND gfa.goalId = ? AND gfa.status = 'active'
     ORDER BY gfa.allocation_date DESC;`,
    [userId, goalId] 
  );
};

// ------------------- WITHDRAWAL MANAGEMENT -------------------

export const createWithdrawalRecord = async (userId, goalId, allocation_id, withdrawal_amount, principal_amount, interest_amount, notes = "") => {
  try {
    const result = await db.runAsync(
      `INSERT INTO withdrawal_records 
       (userId, goalId, allocation_id, withdrawal_amount, principal_amount, interest_amount, notes)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [userId, goalId, allocation_id, withdrawal_amount, principal_amount, interest_amount, notes]
    );
    
    console.log(`âœ… Withdrawal record created for allocation ${allocation_id}`);
    return { success: true, id: result.insertId }; 
  } catch (error) {
    console.error("âŒ createWithdrawalRecord error:", error);
    return { success: false, error: error.message }; 
  }
};

export const confirmWithdrawal = async (userId, withdrawal_id, confirmed_amount) => {
  try {
    console.log("ðŸ”„ Starting withdrawal confirmation...", { userId, withdrawal_id, confirmed_amount });

    // é©—è­‰è¼¸å…¥
    if (!withdrawal_id || !confirmed_amount || confirmed_amount <= 0) {
      throw new Error("Invalid withdrawal confirmation parameters");
    }

    const withdrawal = await db.getFirstAsync(
      `SELECT * FROM withdrawal_records WHERE id = ? AND userId = ? AND status = 'pending'`,
      [withdrawal_id, userId]
    );
    
    if (!withdrawal) {
      throw new Error("Withdrawal record not found or already processed");
    }

    console.log("ðŸ“‹ Withdrawal details:", {
      allocation_id: withdrawal.allocation_id,
      goalId: withdrawal.goalId,
      principal: withdrawal.principal_amount,
      interest: withdrawal.interest_amount
    });

    // é–‹å§‹äº‹å‹™
    await db.execAsync('BEGIN TRANSACTION');
    
    try {
      // 1. æ›´æ–°æå–è¨˜éŒ„ç‹€æ…‹
      console.log("1. Updating withdrawal record status...");
      const updateResult = await db.runAsync(
        `UPDATE withdrawal_records 
         SET status = 'completed', confirmed_amount = ?, confirmed_date = datetime('now')
         WHERE id = ? AND userId = ?`,
        [confirmed_amount, withdrawal_id, userId]
      );
      
      if (updateResult.rowsAffected === 0) {
        throw new Error("Failed to update withdrawal record");
      }

      // 2. æ›´æ–°åˆ†é…ç‹€æ…‹
      console.log("2. Updating fund allocation status...");
      const allocationResult = await db.runAsync(
        `UPDATE goal_fund_allocations SET status = 'withdrawn' WHERE id = ? AND userId = ?`,
        [withdrawal.allocation_id, userId]
      );
      
      if (allocationResult.rowsAffected === 0) {
        throw new Error("Failed to update fund allocation status");
      }

      // 3. æ›´æ–°è³¬æˆ¶é¤˜é¡
      console.log("3. Updating account balance...");
      const accountId = await getAllocationAccountId(withdrawal.allocation_id);
      if (!accountId) {
        throw new Error("Could not find account for allocation");
      }
      
      const accountResult = await db.runAsync(
        `UPDATE saving_accounts SET current_balance = current_balance - ? WHERE id = ? AND userId = ?`,
        [withdrawal.principal_amount, accountId, userId]
      );
      
      if (accountResult.rowsAffected === 0) {
        throw new Error("Failed to update account balance");
      }

      // 4. æ›´æ–°ç›®æ¨™ç•¶å‰é‡‘é¡
      console.log("4. Updating goal current amount...");
      const goalResult = await db.runAsync(
        `UPDATE goals SET currentAmount = currentAmount - ? WHERE id = ? AND userId = ?`,
        [withdrawal.principal_amount, withdrawal.goalId, userId]
      );
      
      if (goalResult.rowsAffected === 0) {
        throw new Error("Failed to update goal current amount");
      }

      // 5. æ›´æ–°ç”¨æˆ¶æ‘˜è¦
      console.log("5. Updating user summary...");
      console.log("   - Releasing expense:", -withdrawal.principal_amount);
      console.log("   - Adding interest income:", withdrawal.interest_amount);
      
      await updateUserSummary(userId, "expense", -withdrawal.principal_amount);
      await updateUserSummary(userId, "income", withdrawal.interest_amount);

      // æäº¤äº‹å‹™
      await db.execAsync('COMMIT');
      
      console.log(`âœ… Withdrawal confirmed successfully: ${withdrawal_id}, amount: ${confirmed_amount}`);
      
      return {
        success: true,
        withdrawal_id: withdrawal_id,
        confirmed_amount: confirmed_amount,
        principal: withdrawal.principal_amount,
        interest: withdrawal.interest_amount
      };
      
    } catch (error) {
      // å›žæ»¾äº‹å‹™
      await db.execAsync('ROLLBACK');
      console.error("âŒ Transaction failed, rolling back...", error);
      throw error;
    }
    
  } catch (error) {
    console.error("âŒ confirmWithdrawal error:", error);
    throw error;
  }
};



// å–æ¶ˆæå–è¨˜éŒ„
export const cancelWithdrawal = async (userId, withdrawal_id) => {
  await db.runAsync(
    `UPDATE withdrawal_records SET status = 'cancelled' WHERE id = ? AND userId = ?`,
    [withdrawal_id, userId]
  );
  console.log(`âœ… Withdrawal cancelled: ${withdrawal_id}`);
};

// ç²å–å¾…è™•ç†çš„æå–è¨˜éŒ„
export const getPendingWithdrawals = async (userId) => {
  return await db.getAllAsync(
    `SELECT wr.*, g.goalName, sa.account_name, sa.institution_name, sm.method_name
     FROM withdrawal_records wr
     JOIN goals g ON wr.goalId = g.id
     JOIN goal_fund_allocations gfa ON wr.allocation_id = gfa.id
     JOIN saving_accounts sa ON gfa.account_id = sa.id
     JOIN saving_methods sm ON sa.method_id = sm.id
     WHERE wr.userId = ? AND wr.status = 'pending'
     ORDER BY wr.withdrawal_date DESC;`,
    [userId]
  );
};

// ç²å–æ‰€æœ‰æå–è¨˜éŒ„
export const getAllWithdrawals = async (userId) => {
  return await db.getAllAsync(
    `SELECT wr.*, g.goalName, sa.account_name, sa.institution_name, sm.method_name
     FROM withdrawal_records wr
     JOIN goals g ON wr.goalId = g.id
     JOIN goal_fund_allocations gfa ON wr.allocation_id = gfa.id
     JOIN saving_accounts sa ON gfa.account_id = sa.id
     JOIN saving_methods sm ON sa.method_id = sm.id
     WHERE wr.userId = ?
     ORDER BY wr.withdrawal_date DESC;`,
    [userId]
  );
};

export const hasPendingWithdrawal = async (userId, allocationId) => {
  try {
    const result = await db.getFirstAsync(
      `SELECT COUNT(*) as count FROM withdrawal_records 
       WHERE userId = ? AND allocation_id = ? AND status = 'pending'`,
      [userId, allocationId]
    );
    return result.count > 0;
  } catch (error) {
    console.error("âŒ hasPendingWithdrawal error:", error);
    return false;
  }
};

// è¼”åŠ©å‡½æ•¸ï¼šç²å–åˆ†é…çš„è³¬æˆ¶ID
const getAllocationAccountId = async (allocation_id) => {
  const result = await db.getFirstAsync(
    `SELECT account_id FROM goal_fund_allocations WHERE id = ?`,
    [allocation_id]
  );
  return result?.account_id;
};

// ------------------- MATURITY MANAGEMENT -------------------

// æª¢æŸ¥åˆ°æœŸçš„åˆ†é…
export const checkMaturedAllocations = async (userId) => {
  const today = new Date().toISOString().split('T')[0];
  
  const maturedAllocations = await db.getAllAsync(
    `SELECT gfa.*, g.goalName, sa.account_name, sa.institution_name
     FROM goal_fund_allocations gfa
     JOIN goals g ON gfa.goalId = g.id
     JOIN saving_accounts sa ON gfa.account_id = sa.id
     WHERE gfa.userId = ? AND gfa.status = 'active' AND gfa.maturity_date <= ?`,
    [userId, today]
  );
  
  return maturedAllocations;
};

// è‡ªå‹•è™•ç†åˆ°æœŸåˆ†é…
export const processMaturedAllocations = async (userId) => {
  try {
    const maturedAllocations = await checkMaturedAllocations(userId);
    
    for (const allocation of maturedAllocations) {
      // è¨ˆç®—åˆ©æ¯
      const interest_amount = allocation.current_value - allocation.allocated_amount;
      
      // å‰µå»ºæå–è¨˜éŒ„ï¼ˆè‡ªå‹•ç¢ºèªï¼‰
      await createWithdrawalRecord(
        userId, 
        allocation.goalId, 
        allocation.id, 
        allocation.current_value,
        allocation.allocated_amount,
        interest_amount,
        "Auto-processed upon maturity"
      );
      
      // è‡ªå‹•ç¢ºèªæå–
      const withdrawal = await db.getFirstAsync(
        `SELECT id FROM withdrawal_records 
         WHERE allocation_id = ? AND status = 'pending' 
         ORDER BY id DESC LIMIT 1`,
        [allocation.id]
      );
      
      if (withdrawal) {
        await confirmWithdrawal(userId, withdrawal.id, allocation.current_value);
      }
      
      console.log(`âœ… Matured allocation processed: ${allocation.id}`);
    }
    
    return maturedAllocations.length;
  } catch (error) {
    console.error("âŒ processMaturedAllocations error:", error);
    throw error;
  }
};

// ------------------- VALUE UPDATES -------------------

// æ‰‹å‹•æ›´æ–°åˆ†é…ç•¶å‰åƒ¹å€¼
export const updateAllocationCurrentValue = async (userId, allocation_id, new_current_value) => {
  await db.runAsync(
    `UPDATE goal_fund_allocations SET current_value = ? WHERE id = ? AND userId = ?`,
    [new_current_value, allocation_id, userId]
  );
  
  // é‡æ–°è¨ˆç®—ç›®æ¨™ç¸½é‡‘é¡
  await recalculateGoalCurrentAmount(userId, await db.getFirstAsync(
    `SELECT goalId FROM goal_fund_allocations WHERE id = ?`, [allocation_id]
  ).goalId);
};

// é‡æ–°è¨ˆç®—ç›®æ¨™ç•¶å‰é‡‘é¡
const recalculateGoalCurrentAmount = async (userId, goalId) => {
  const allocations = await db.getAllAsync(
    `SELECT current_value FROM goal_fund_allocations 
     WHERE userId = ? AND goalId = ? AND status = 'active'`,
    [userId, goalId]
  );
  
  const totalCurrentValue = allocations.reduce((sum, alloc) => sum + (alloc.current_value || 0), 0);
  
  await db.runAsync(
    `UPDATE goals SET currentAmount = ? WHERE id = ? AND userId = ?`,
    [totalCurrentValue, goalId, userId]
  );
};