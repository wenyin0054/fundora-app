import { DeviceEventEmitter } from "react-native";
import { Alert } from "react-native";
import * as SQLite from "expo-sqlite";

let dbInstance = null;
let isInitialized = false;

// Initialize database connection once and reuse
export const initDatabaseConnection = async () => {
  console.log("üîÑ initDatabaseConnection called, dbInstance exists:", !!dbInstance);
  if (dbInstance) {
    console.log("‚úÖ Returning existing dbInstance");
    return dbInstance;
  }

  try {
    console.log("üîÑ Initializing database connection...");
    dbInstance = await SQLite.openDatabaseAsync('fundora.db');
    console.log("‚úÖ Database connection established, dbInstance:", !!dbInstance);
    return dbInstance;
  } catch (error) {
    console.error("‚ùå Failed to initialize database:", error);
    dbInstance = null;
    throw error;
  }
};

// Get database instance with error checking
const getDatabase = async () => {
  if (!dbInstance) {
    throw new Error("Database not initialized - call initDatabaseConnection() first");
  }
  return dbInstance;
};

// ------------------- DATABASE INITIALIZATION -------------------
export const initDB = async () => {
  if (isInitialized) {
    console.log("‚öôÔ∏è Database already initialized, skipping...");
    return;
  }

  try {
    console.log("‚öôÔ∏è Initializing Fundora database...");
    const database = await initDatabaseConnection();

    // üë§ Users Table
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS users (
        userId TEXT PRIMARY KEY,
        username TEXT UNIQUE,
        email TEXT UNIQUE,
        created_at TEXT DEFAULT (datetime('now'))
      );
    `);

    // üßæ User Summary Table
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS user_summary (
        userId TEXT PRIMARY KEY,
        total_income REAL DEFAULT 0,
        total_expense REAL DEFAULT 0,
        total_balance REAL DEFAULT 0,
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // üßæ Expenses Table
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS expenses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        payee TEXT,
        amount REAL,
        date TEXT,
        tag TEXT,
        eventTag TEXT,
        paymentType TEXT,
        isPeriodic INTEGER,
        type TEXT,
        typeLabel TEXT,
        essentialityLabel INTEGER,
        goalId INTEGER,
        periodInterval INTEGER DEFAULT 0,
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // üè¶ Goals Table
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS goals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        goalName TEXT,
        description TEXT,
        targetAmount REAL,
        currentAmount REAL,
        deadline TEXT,
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // üè∑Ô∏è Tags Table
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS tags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        name TEXT UNIQUE,
        essentialityLabel INTEGER,
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // üè∑Ô∏è Event Tags Table
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS eventTags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        name TEXT UNIQUE,
        description TEXT,
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS activeEventTags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        eventTagId INTEGER,
        startDate TEXT,
        endDate TEXT,
        FOREIGN KEY (userId) REFERENCES users(userId),
        FOREIGN KEY (eventTagId) REFERENCES eventTags(id)
      );
    `);

    // üßæ Bills Table
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS bills (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        billName TEXT,
        category TEXT,
        amount REAL,
        dueDate TEXT,
        status TEXT DEFAULT 'Upcoming',
        isAutoGenerated INTEGER DEFAULT 0,
        isCommitment INTEGER DEFAULT 0,
        periodType TEXT DEFAULT 'Yearly',
        periodInterval INTEGER DEFAULT 0,
        createdAt TEXT DEFAULT (date('now')),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // Reminders Table
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS reminders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        billId INTEGER,
        userId TEXT,
        message TEXT,
        reminderDate TEXT,
        status TEXT DEFAULT 'Active',
        createdAt TEXT DEFAULT (date('now')),
        FOREIGN KEY (userId) REFERENCES users(userId),
        FOREIGN KEY (billId) REFERENCES bills(id)
      );
    `);

    // Predictor Cache
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS predictor_cache (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        payee_normalized TEXT NOT NULL,
        tag TEXT NOT NULL,
        count INTEGER DEFAULT 1,
        confidence REAL DEFAULT 1.0,
        last_used INTEGER DEFAULT (strftime('%s','now')),
        is_custom INTEGER DEFAULT 0,
        UNIQUE(user_id, payee_normalized),
        FOREIGN KEY (user_id) REFERENCES users(userId)
      );
    `);

    // Saving Methods
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS saving_methods (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        method_name TEXT,
        method_type TEXT,
        risk_level INTEGER,
        liquidity_level INTEGER,
        expected_return REAL,
        color_code TEXT,
        icon_name TEXT,
        is_default INTEGER DEFAULT 0,
        UNIQUE(userId, method_name),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // Saving Accounts Table
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS saving_accounts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        method_id INTEGER,
        account_name TEXT,
        institution_name TEXT,
        account_number TEXT,
        current_balance REAL DEFAULT 0,
        interest_rate REAL,
        maturity_date TEXT,
        notes TEXT,
        FOREIGN KEY (method_id) REFERENCES saving_methods(id),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // Goal Fund Allocations Table
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS goal_fund_allocations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        goalId INTEGER,
        method_id INTEGER,
        account_id INTEGER,
        allocated_amount REAL,
        allocation_date TEXT,
        transaction_id INTEGER,
        maturity_date TEXT,
        current_value REAL,
        expected_value REAL,
        status TEXT DEFAULT 'active',
        notes TEXT,
        FOREIGN KEY (goalId) REFERENCES goals(id),
        FOREIGN KEY (account_id) REFERENCES saving_accounts(id),
        FOREIGN KEY (transaction_id) REFERENCES expenses(id),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // Withdrawal Records
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS withdrawal_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        goalId INTEGER,
        allocation_id INTEGER,
        withdrawal_amount REAL,
        principal_amount REAL,
        interest_amount REAL,
        withdrawal_date TEXT DEFAULT (datetime('now')),
        status TEXT DEFAULT 'pending',
        confirmed_amount REAL,
        confirmed_date TEXT,
        notes TEXT,
        FOREIGN KEY (goalId) REFERENCES goals(id),
        FOREIGN KEY (allocation_id) REFERENCES goal_fund_allocations(id),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);

    // ------------------- Income Snapshots Table -------------------
    await database.execAsync(`
      CREATE TABLE IF NOT EXISTS income_snapshots (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT,
        month TEXT,
        income_amount REAL DEFAULT 0,
        created_at TEXT DEFAULT (datetime('now')),
        UNIQUE(userId, month),
        FOREIGN KEY (userId) REFERENCES users(userId)
      );
    `);


    console.log("‚úÖ All database tables are ready with user isolation");
    isInitialized = true;
  } catch (error) {
    console.error("‚ùå initDB error:", error);
    throw error;
  }
};

// ------------------- USER MANAGEMENT -------------------
export const createUser = async (userId, username = null, email = null) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `INSERT OR IGNORE INTO users (userId, username, email) VALUES (?, ?, ?)`,
      [userId, username, email]
    );
    console.log(`‚úÖ User ${userId} created/verified`);
  } catch (error) {
    console.error("‚ùå createUser error:", error);
  }
};

// ------------------- USER SUMMARY TABLE -------------------
export const createUserSummary = async (userId) => {
  const database = await getDatabase();
  await database.runAsync(
    `INSERT OR IGNORE INTO user_summary (userId, total_income, total_expense, total_balance)
     VALUES (?, 0, 0, 0)`,
    [userId]
  );
};

export const getUserSummary = async (userId) => {
  const database = await getDatabase();
  const result = await database.getFirstAsync(
    `SELECT total_income, total_expense, total_balance FROM user_summary WHERE userId = ?`,
    [userId]
  );
  return result || { total_income: 0, total_expense: 0, total_balance: 0 };
};

export const updateUserSummary = async (userId, type, amount) => {
  // await createUserSummary(userId);
  // console.log("Updating user summary:", { userId, type, amount });

  // const database = await getDatabase();
  // if (type === "income") {
  //   await database.runAsync(
  //     `UPDATE user_summary
  //      SET total_income = total_income + ?,
  //          total_balance = total_balance + ?
  //      WHERE userId = ?`,
  //     [amount, amount, userId]
  //   );
  // } else if (type === "expense") {
  //   await database.runAsync(
  //     `UPDATE user_summary
  //      SET total_expense = total_expense + ?,
  //          total_balance = total_balance - ?
  //      WHERE userId = ?`,
  //     [amount, amount, userId]
  //   );
  // }

  // const summary = await getUserSummary(userId);
  // console.log("üìä Updated user summary:", summary);

  throw new Error(
    "‚ùå updateUserSummary() is deprecated. Use updateUserSummaryOnAdd/Edit/Delete only."
  );


};

export const resetUserSummary = async (userId) => {
  const database = await getDatabase();
  await database.runAsync(
    `UPDATE user_summary
     SET total_income = 0, total_expense = 0, total_balance = 0
     WHERE userId = ?`,
    [userId]
  );
};

export const updateUserSummaryOnAdd = async (userId, type, amount) => {
  try {
    const amountNum = parseFloat(amount);

    const summary = await getUserSummary(userId);
    const currentExpense = summary.total_expense || 0;
    const currentIncome = summary.total_income || 0;
    const currentBalance = summary.total_balance || 0;

    let newExpense = currentExpense;
    let newIncome = currentIncome;
    let newBalance = currentBalance;

    if (type === "expense") {
      newExpense = currentExpense + amountNum;
      newBalance = currentBalance - amountNum;
    } else if (type === "income") {
      newIncome = currentIncome + amountNum;
      newBalance = currentBalance + amountNum;
    }

    const database = await getDatabase();
    const results = await database.runAsync(
      `UPDATE user_summary SET total_expense = ?, total_income = ?, total_balance = ? WHERE userId = ?`,
      [newExpense, newIncome, newBalance, userId]
    );

    console.log(`‚úÖ Summary updated - Expense: ${currentExpense}->${newExpense}, Income: ${currentIncome}->${newIncome}, Balance: ${currentBalance}->${newBalance}`);
    return results;
  } catch (error) {
    console.error(`‚ùå Error adding to summary:`, error);
    throw error;
  }
};

export const updateUserSummaryOnEdit = async (
  userId,
  oldType,
  oldAmount,
  newType,
  newAmount
) => {
  try {
    const oldA = Number(oldAmount);
    const newA = Number(newAmount);

    if (!Number.isFinite(oldA) || !Number.isFinite(newA)) {
      console.warn("‚ö†Ô∏è Invalid amount in updateUserSummaryOnEdit", {
        oldAmount,
        newAmount,
      });
      return;
    }

    // 1Ô∏è‚É£ Reverse old transaction effect
    await updateUserSummaryOnDelete(userId, oldType, oldA);

    // 2Ô∏è‚É£ Apply new transaction effect
    await updateUserSummaryOnAdd(userId, newType, newA);

  } catch (err) {
    console.error("‚ùå updateUserSummaryOnEdit failed:", err);
    throw err;
  }
};




export const updateUserSummaryOnDelete = async (userId, type, amount) => {
  try {
    const amountNum = parseFloat(amount);

    const summary = await getUserSummary(userId);
    const currentExpense = summary.total_expense || 0;
    const currentIncome = summary.total_income || 0;
    const currentBalance = summary.total_balance || 0;

    let newExpense = currentExpense;
    let newIncome = currentIncome;
    let newBalance = currentBalance;

    if (type === "expense") {
      newExpense = currentExpense - amountNum;
      newBalance = currentBalance + amountNum;
    } else if (type === "income") {
      newIncome = currentIncome - amountNum;
      newBalance = currentBalance - amountNum;
    }

    const database = await getDatabase();
    const results = await database.runAsync(
      `UPDATE user_summary SET total_expense = ?, total_income = ?, total_balance = ? WHERE userId = ?`,
      [newExpense, newIncome, newBalance, userId]
    );

    console.log(`‚úÖ Summary deleted - Expense: ${currentExpense}->${newExpense}, Income: ${currentIncome}->${newIncome}, Balance: ${currentBalance}->${newBalance}`);
    return results;
  } catch (error) {
    console.error(`‚ùå Error deleting from summary:`, error);
    throw error;
  }
};

// -------------------- EXPENSES CRUD -------------------
export const addExpenseLocal = async (
  userId,
  payee,
  amount,
  date,
  tag,
  eventTag,
  paymentType,
  isPeriodic,
  type,
  typeLabel,
  essentialityLabel,
  goalId,
  periodInterval = 0
) => {
  try {
    const database = await getDatabase();
    const result = await database.runAsync(
      `INSERT INTO expenses (
        userId, payee, amount, date, tag, eventTag,
        paymentType, isPeriodic, type, typeLabel,
        essentialityLabel, goalId, periodInterval
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        userId,
        payee,
        amount,
        date,
        tag,
        eventTag,
        paymentType,
        isPeriodic ? 1 : 0,
        type,
        typeLabel,
        essentialityLabel,
        goalId,
        periodInterval,
      ]
    );

    console.log("‚úÖ Expense added successfully:", typeLabel);
    console.log("üßæ Added Detail:", {
      userId, payee, amount, date, tag, eventTag, paymentType,
      isPeriodic, typeLabel, essentialityLabel, goalId, periodInterval
    });

    return result.lastInsertRowId;

  } catch (error) {
    console.error("‚ùå addExpenseLocal error:", error);
    throw error;
  }
};

// Get all expenses for a specific user
export const getExpensesLocal = async (userId) => {
  try {
    const database = await getDatabase();
    const results = await database.getAllAsync(
      `SELECT * FROM expenses WHERE userId = ? ORDER BY date DESC;`,
      [userId]
    );
    const normalized = results.map(item => ({
      ...item,
      amount: parseFloat(item.amount) || 0,
      essentialityLabel: Number(item.essentialityLabel),
      isPeriodic: Number(item.isPeriodic),
      periodInterval: Number(item.periodInterval) || 1,
    }));
    return normalized;
  } catch (error) {
    console.error("‚ùå getExpensesLocal error:", error);
    return [];
  }
};
export const getTotalExpensesLocal = async (userId) => {
  try {
    const database = await getDatabase();
    const result = await database.getFirstAsync(
      `SELECT total_expense FROM user_summary WHERE userId = ?`,
      [userId]
    );

    return result?.total_expense || 0;
  } catch (error) {
    console.error("‚ùå getTotalExpensesLocal error:", error);
    return 0;
  }
};


// Delete expense by ID (keep original functionality, but ensure only delete the user's data)
export const deleteExpenseLocal = async (userId, id) => {
  try {
    const database = await getDatabase();
    await database.runAsync(`DELETE FROM expenses WHERE id = ? AND userId = ?;`, [id, userId]);
    console.log(`üóëÔ∏è Expense with ID ${id} deleted for user ${userId}`);
  } catch (error) {
    console.error("‚ùå deleteExpenseLocal error:", error);
  }
};

// Delete expense with proper UserSummary handling (single source of truth)
export const deleteExpenseWithSummary = async (userId, expenseId) => {
  const database = await getDatabase();

  const expense = await database.getFirstAsync(
    `SELECT * FROM expenses WHERE id = ? AND userId = ?`,
    [expenseId, userId]
  );

  if (!expense) throw new Error("Expense not found");

  // ‚ùó Allocation / transaction expense summary is handled elsewhere
  if (expense.goalId) {
    await database.runAsync(
      `DELETE FROM expenses WHERE id = ? AND userId = ?`,
      [expenseId, userId]
    );
    return { success: true, summaryUpdated: false };
  }


  // ‚úÖ STEP 1: UPDATE USER SUMMARY (DELETE RULE)
  await updateUserSummaryOnDelete(
    userId,
    expense.typeLabel,
    expense.amount
  );

  // ‚úÖ STEP 2: DELETE EXPENSE RECORD
  await database.runAsync(
    `DELETE FROM expenses WHERE id = ? AND userId = ?`,
    [expenseId, userId]
  );

  return { success: true };
};



// Update expense
export const updateExpenseLocal = async (
  id,               // ‚ù∂ expense ID
  userId,           // ‚ù∑ user ID
  payee,
  amount,
  date,
  tag,
  eventTag,
  paymentType,
  isPeriodic,
  type,
  typeLabel,
  essentialityLabel,
  goalId,
  periodInterval
) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `UPDATE expenses
       SET 
         payee = ?, 
         amount = ?, 
         date = ?, 
         tag = ?, 
         eventTag = ?, 
         paymentType = ?, 
         isPeriodic = ?, 
         type = ?, 
         typeLabel = ?, 
         essentialityLabel = ?, 
         goalId = ?, 
         periodInterval = ?
       WHERE id = ? AND userId = ?;`,
      [
        payee,
        amount,
        date,
        tag,
        eventTag,
        paymentType,
        isPeriodic ? 1 : 0,
        type,
        typeLabel,
        essentialityLabel ?? 0,
        goalId ?? null,
        periodInterval ?? 0,
        id,         // correct
        userId,     // correct
      ]
    );

    console.log(`‚úÖ Expense record updated successfully (ID: ${id}) for user ${userId}`);
  } catch (error) {
    console.error("‚ùå Error updating expense in local database:", error);
  }
};


export const getPeriodicExpensesLocal = async (userId) => {
  try {
    const database = await getDatabase();
    const results = await database.getAllAsync(
      `SELECT * FROM expenses WHERE userId = ? AND isPeriodic = 1 ORDER BY date DESC;`,
      [userId]
    );

    return results.map(r => ({
      ...r,
      amount: parseFloat(r.amount) || 0,
      essentialityLabel: Number(r.essentialityLabel),
      isPeriodic: Number(r.isPeriodic),
      periodInterval: Number(r.periodInterval) || 1,
    }));
  } catch (err) {
    console.error("‚ùå getPeriodicExpensesLocal error:", err);
    return [];
  }
};

export const clearAllExpensesLocal = async (userId) => {
  try {
    const database = await getDatabase();
    await database.runAsync(`DELETE FROM expenses WHERE userId = ?;`, [userId]);
    console.log(`üóëÔ∏è All expenses cleared for user ${userId}`);
  } catch (error) {
    console.error("‚ùå clearAllExpensesLocal error:", error);
  }
};


// üßÆ Get total and essential total expenses for last month for specific user
export const getLastMonthTotalExpense = async (userId) => {
  try {
    const database = await getDatabase();
    const results = await database.getAllAsync(
      `SELECT
        SUM(amount) AS total,
        SUM(CASE WHEN essentialityLabel = 1 THEN amount ELSE 0 END) AS essentialTotal
      FROM expenses
      WHERE userId = ? AND strftime('%Y-%m', date) = strftime('%Y-%m', 'now', '-1 month');`,
      [userId]
    );

    const row = results?.[0] || {};
    const total = parseFloat(row.total) || 0;
    const essentialTotal = parseFloat(row.essentialTotal) || 0;

    console.log("‚úÖ Last month expenses for user", userId, ":", { total, essentialTotal });
    return { total, essentialTotal };
  } catch (error) {
    console.error("‚ùå getLastMonthTotalExpense error:", error);
    return { total: 0, essentialTotal: 0 };
  }
};

export const getCurrentMonthlyIncome = async (userId) => {
  try {
    const database = await getDatabase();
    const result = await database.getFirstAsync(
      `SELECT SUM(amount) AS totalIncome
       FROM expenses
       WHERE userId = ?
       AND typeLabel = 'income'
       AND strftime('%Y-%m', date) = strftime('%Y-%m', 'now');`,
      [userId]
    );

    return result?.totalIncome ? parseFloat(result.totalIncome) : 0;
  } catch (error) {
    console.error("‚ùå getCurrentMonthlyIncome error:", error);
    return 0;
  }
};

export const getCurrentMonthlyExpenses = async (userId) => {
  try {
    const database = await getDatabase();

    const result = await database.getFirstAsync(
      `
      SELECT SUM(amount) AS totalExpenses
      FROM expenses
      WHERE userId = ?
        AND (
          typeLabel = 'expense'
          OR (typeLabel = 'transaction' AND goalId IS NULL)
        )
        AND strftime('%Y-%m', date) = strftime('%Y-%m', 'now');
      `,
      [userId]
    );

    console.log(
      "‚úÖ Current monthly expenses for user",
      userId,
      ":",
      result?.totalExpenses
    );

    return result?.totalExpenses
      ? parseFloat(result.totalExpenses)
      : 0;
  } catch (error) {
    console.error("‚ùå getCurrentMonthlyExpenses error:", error);
    return 0;
  }
};


export const getExpensesByTypeLabelLocal = async (userId, typeLabel) => {
  try {
    const database = await getDatabase();
    if (!database || !database.getAllAsync) {
      throw new Error("‚ùå DB is not initialized or missing getAllAsync method");
    }

    const allowedTypes = ["income", "expense", "transaction"];
    if (!allowedTypes.includes(typeLabel)) {
      throw new Error(`‚ùå Invalid typeLabel: ${typeLabel}`);
    }

    const results = await database.getAllAsync(
      `SELECT * FROM expenses WHERE userId = ? AND typeLabel = ? ORDER BY date DESC`,
      [userId, typeLabel]
    );

    console.log(`‚úÖ Fetched ${results.length} rows for typeLabel: ${typeLabel} for user ${userId}`);
    return results;
  } catch (error) {
    console.error("‚ùå getExpensesByTypeLabelLocal error:", error);
    return [];
  }
};


// ------------------- GOALS CRUD -------------------
export const createGoalTable = async (userId) => {
  const database = await getDatabase();
  await database.execAsync(`
    DROP TABLE IF EXISTS goals;
  `);
  await database.execAsync(`
    CREATE TABLE IF NOT EXISTS goals (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      userId TEXT,
      goalName TEXT,
      description TEXT,
      targetAmount REAL,
      currentAmount REAL,
      deadline TEXT,
      FOREIGN KEY (userId) REFERENCES users(userId)
    );
  `);
};

export const addGoalLocal = async (userId, goalName, description, targetAmount, currentAmount, deadline) => {
  const database = await getDatabase();
  await database.runAsync(
    `INSERT INTO goals (userId, goalName, description, targetAmount, currentAmount, deadline)
     VALUES (?, ?, ?, ?, ?, ?);`,
    [userId, goalName, description, targetAmount, currentAmount, deadline]
  );
};

export const getGoalsLocal = async (userId) => {
  const database = await getDatabase();
  return await database.getAllAsync(
    `SELECT * FROM goals WHERE userId = ? ORDER BY deadline ASC;`,
    [userId]
  );
};

export const getGoalById = async (userId, goalId) => {
  const database = await getDatabase();
  const res = await database.getFirstAsync(
    `SELECT * FROM goals WHERE userId = ? AND id = ?`,
    [userId, goalId]
  );
  return res;
};


export const updateGoalLocal = async (userId, id, goalName, description, targetAmount, currentAmount, deadline) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `UPDATE goals
       SET goalName = ?, description = ?, targetAmount = ?, currentAmount = ?, deadline = ?
       WHERE id = ? AND userId = ?;`,
      [goalName, description, targetAmount, currentAmount, deadline, id, userId]
    );
    console.log(`‚úÖ Goal ID ${id} updated for user ${userId}`);
  } catch (error) {
    console.error("‚ùå updateGoalLocal error:", error);
  }
};

export const deleteGoalLocal = async (userId, id) => {
  try {
    const database = await getDatabase();
    await database.runAsync(`DELETE FROM goals WHERE id = ? AND userId = ?;`, [id, userId]);
    console.log(`üóëÔ∏è Goal ID ${id} deleted for user ${userId}`);
  } catch (error) {
    console.error("‚ùå deleteGoalLocal error:", error);
  }
};

export const deleteAllGoals = async () => {
  try {
    const database = await getDatabase();
    await database.runAsync(`DELETE FROM goals;`);
    console.log("üóëÔ∏è All goals deleted successfully");
  } catch (error) {
    console.error("‚ùå deleteAllGoals error:", error);
  }
};


// Update currentAmount of a goal by adding amount
export const updateGoalAmount = async (userId, goalId, amount) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `UPDATE goals
       SET currentAmount = currentAmount + ?
       WHERE id = ? AND userId = ?`,
      [amount, goalId, userId]
    );
    console.log(`‚úÖ Goal ${goalId} updated by ${amount} for user ${userId}`);
  } catch (error) {
    console.error("‚ùå Error updating goal amount:", error);
  }
};
export const isGoalNameDuplicate = async (userId, goalName) => {
  try {
    const database = await getDatabase();
    const result = await database.getFirstAsync(
      `SELECT id FROM goals WHERE userId = ? AND LOWER(goalName) = LOWER(?) LIMIT 1`,
      [userId, goalName.trim()]
    );
    return !!result;
  } catch (error) {
    console.error("‚ùå isGoalNameDuplicate error:", error);
    return false;
  }
};


// ------------------- TAGS CRUD -------------------
export const createTagTable = async () => {
  const database = await getDatabase();
  await database.execAsync(`
    CREATE TABLE IF NOT EXISTS tags (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      userId TEXT,
      name TEXT UNIQUE,
      essentialityLabel INTEGER,
      FOREIGN KEY (userId) REFERENCES users(userId)
    );
  `);
};

export const addTagLocal = async (userId, name, essentialityLabel) => {
  const database = await getDatabase();
  await database.runAsync(
    `INSERT INTO tags (userId, name, essentialityLabel)
     VALUES (?, ?, ?);`,
    [userId, name, essentialityLabel]
  );
};

export const getTagsLocal = async (userId) => {
  const database = await getDatabase();
  return await database.getAllAsync(
    `SELECT * FROM tags WHERE userId = ? ORDER BY name ASC;`,
    [userId]
  );
};

export const deleteTagLocal = async (userId, id) => {
  try {
    const database = await getDatabase();
    await database.runAsync(`DELETE FROM tags WHERE id = ? AND userId = ?;`, [id, userId]);
    console.log(`üóëÔ∏è Tag ID ${id} deleted for user ${userId}`);
  } catch (error) {
    console.error("‚ùå deleteTagLocal error:", error);
  }
};

export const getUserVisibleTags = async (userId) => {
  const database = await getDatabase();
  return await database.getAllAsync(
    `
    SELECT *
    FROM tags
    WHERE userId = ?
    ORDER BY name ASC
    `,
    [userId]
  );
};


// ------------------- EVENT TAGS CRUD -------------------
export const createEventTagTable = async () => {
  const database = await getDatabase();
  await database.execAsync(`
    CREATE TABLE IF NOT EXISTS eventTags (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      userId TEXT,
      name TEXT UNIQUE,
      description TEXT,
      FOREIGN KEY (userId) REFERENCES users(userId)
    );
  `);
  console.log("‚úÖ eventTags table ready");
};

export const addEventTagLocal = async (userId, name, description = null) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `INSERT INTO eventTags (userId, name, description)
       VALUES (?, ?, ?);`,
      [userId, name, description]
    );
    console.log(`‚úÖ Event tag '${name}' added for user ${userId}`);
    DeviceEventEmitter.emit("eventTagsUpdated");
    return true; // ‚úÖ Add this line
  } catch (error) {
    if (error.message.includes("UNIQUE constraint failed")) {
      console.warn(`‚ö†Ô∏è Event tag '${name}' already exists for user ${userId}`);
      return false; // ‚úÖ Add this line
    } else {
      console.error("‚ùå addEventTagLocal error:", error);
      return false; // ‚úÖ Add this line
    }
  }
};
export const getEventTagsLocal = async (userId) => {
  try {
    const database = await getDatabase();
    const results = await database.getAllAsync(
      `SELECT * FROM eventTags WHERE userId = ? ORDER BY name ASC;`,
      [userId]
    );
    console.log(`‚úÖ Retrieved ${results.length} event tags for user ${userId}`);
    return results;
  } catch (error) {
    console.error("‚ùå getEventTagsLocal error:", error);
    return [];
  }
};

export const updateEventTagLocal = async (userId, id, newName, newDescription) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `UPDATE eventTags
       SET name = ?, description = ?
       WHERE id = ? AND userId = ?;`,
      [newName, newDescription, id, userId]
    );
    console.log(`‚úÖ Event tag ID ${id} updated for user ${userId}`);
    DeviceEventEmitter.emit("eventTagsUpdated");
  } catch (error) {
    console.error("‚ùå updateEventTagLocal error:", error);
  }
};

export const deleteEventTagLocal = async (userId, id) => {
  try {
    const database = await getDatabase();
    await database.runAsync(`DELETE FROM eventTags WHERE id = ? AND userId = ?;`, [id, userId]);
    console.log(`üóëÔ∏è Event tag ID ${id} deleted for user ${userId}`);
    DeviceEventEmitter.emit("eventTagsUpdated");
  } catch (error) {
    console.error("‚ùå deleteEventTagLocal error:", error);
  }
};

// ------------------- ACTIVE EVENT TAGS CRUD -------------------
export const addActiveEventTagLocal = async (userId, eventTagId, startDate, endDate) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `INSERT INTO activeEventTags (userId, eventTagId, startDate, endDate) VALUES (?, ?, ?, ?);`,
      [userId, eventTagId, startDate, endDate]
    );
    console.log(`‚úÖ Active event tag added for user ${userId}`);
  } catch (error) {
    console.error("‚ùå addActiveEventTagLocal error:", error);
  }
};

export const getActiveEventTagsLocal = async (userId) => {
  try {
    const database = await getDatabase();
    const results = await database.getAllAsync(
      `SELECT aet.id, aet.startDate, aet.endDate, et.name
       FROM activeEventTags aet
       JOIN eventTags et ON aet.eventTagId = et.id
       WHERE aet.userId = ?
       ORDER BY aet.startDate DESC;`,
      [userId]
    );
    return results;
  } catch (error) {
    console.error("‚ùå getActiveEventTagsLocal error:", error);
    return [];
  }
};

export const deleteActiveEventTagLocal = async (userId, id) => {
  try {
    const database = await getDatabase();
    await database.runAsync(`DELETE FROM activeEventTags WHERE id = ? AND userId = ?;`, [id, userId]);
    console.log(`üóëÔ∏è Active event tag ID ${id} deleted for user ${userId}`);
  } catch (error) {
    console.error("‚ùå deleteActiveEventTagLocal error:", error);
  }
};

export const clearAllActiveEventTagsLocal = async (userId) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `DELETE FROM activeEventTags WHERE userId = ?;`,
      [userId]
    );
    console.log(`üóëÔ∏è All active event tags for user ${userId} cleared`);
  } catch (error) {
    console.error("‚ùå clearAllActiveEventTagsLocal error:", error);
  }
};

// ------------------- Bills CRUD -------------------
export const addBillLocal = async ({
  userId,
  billName,
  category = "",
  amount = 0,
  dueDate,
  isAutoGenerated = 0,
  isCommitment = 0,
  periodType = "Yearly",
  periodInterval = 0,
}) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `INSERT INTO bills
        (userId, billName, category, amount, dueDate, isAutoGenerated, isCommitment, periodType, periodInterval)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);`,
      [
        userId,
        billName,
        category,
        amount,
        dueDate,
        isAutoGenerated ? 1 : 0,
        isCommitment ? 1 : 0,
        periodType,
        periodInterval,
      ]
    );
    return true;
  } catch (err) {
    console.error("‚ùå addBillLocal error:", err);
    throw err;
  }
};

export const getBillsLocal = async (userId) => {
  try {
    const database = await getDatabase();
    const results = await database.getAllAsync(
      `SELECT * FROM bills WHERE userId = ? ORDER BY dueDate ASC;`,
      [userId]
    );

    return results.map(r => ({
      ...r,
      amount: parseFloat(r.amount) || 0,
      isAutoGenerated: Number(r.isAutoGenerated || 0),
      isCommitment: Number(r.isCommitment || 0),
      periodType: r.periodType || "Yearly",
      periodInterval: Number(r.periodInterval || 0),
    }));
  } catch (err) {
    console.error("‚ùå getBillsLocal error:", err);
    return [];
  }
};

export const getPeriodicBillsLocal = async (userId) => {
  try {
    const database = await getDatabase();
    const results = await database.getAllAsync(
      `SELECT * FROM bills WHERE userId = ? AND isAutoGenerated = 1 ORDER BY dueDate ASC;`,
      [userId]
    );

    return results.map(r => ({
      ...r,
      amount: parseFloat(r.amount) || 0,
      isAutoGenerated: Number(r.isAutoGenerated || 0),
      isCommitment: Number(r.isCommitment || 0),
      periodType: r.periodType || "Yearly",
      periodInterval: Number(r.periodInterval || 1),
      isPeriodic: Number(r.isPeriodic || 0),
    }));
  } catch (err) {
    console.error("‚ùå getPeriodicBillsLocal error:", err);
    return [];
  }
};

export const getAutoGeneratedBillsLocal = async (userId) => {
  try {
    const database = await getDatabase();
    const results = await database.getAllAsync(
      `SELECT * FROM bills WHERE userId = ? AND isAutoGenerated = 1 ORDER BY dueDate ASC;`,
      [userId]
    );

    return results.map(r => ({
      ...r,
      amount: parseFloat(r.amount) || 0,
      isAutoGenerated: Number(r.isAutoGenerated || 0),
      isCommitment: Number(r.isCommitment || 0),
      periodType: r.periodType || "Yearly",
      periodInterval: Number(r.periodInterval || 0),
    }));
  } catch (err) {
    console.error("‚ùå getAutoGeneratedBillsLocal error:", err);
    return [];
  }
};

export const updateBillLocal = async (userId, id, fields = {}) => {
  try {
    const database = await getDatabase();
    const setters = [];
    const values = [];

    for (const [k, v] of Object.entries(fields)) {
      setters.push(`${k} = ?`);
      values.push(v);
    }

    if (setters.length === 0) return;

    values.push(id);
    values.push(userId);

    const sql = `UPDATE bills SET ${setters.join(", ")} WHERE id = ? AND userId = ?;`;
    await database.runAsync(sql, values);

    return true;
  } catch (err) {
    console.error("‚ùå updateBillLocal error:", err);
    throw err;
  }
};

export const deleteBillLocal = async (userId, id) => {
  try {
    const database = await getDatabase();
    await database.runAsync(`DELETE FROM reminders WHERE billId = ?;`, [id]);
    await database.runAsync(`DELETE FROM bills WHERE id = ? AND userId = ?;`, [id, userId]);
    return true;
  } catch (err) {
    console.error("‚ùå deleteBillLocal error:", err);
    throw err;
  }
};
export const isBillNameDuplicate = async (userId, billName) => {
  try {
    const database = await getDatabase();
    const result = await database.getFirstAsync(
      `SELECT id FROM bills WHERE userId = ? AND LOWER(billName) = LOWER(?) LIMIT 1`,
      [userId, billName.trim()]
    );
    return !!result; // true = duplicate
  } catch (error) {
    console.error("‚ùå isBillNameDuplicate error:", error);
    return false;
  }
};


// ------------------- reminder CRUD -------------------
export const getRemindersLocal = async (userId, limit = 5) => {
  try {
    const database = await getDatabase();
    const results = await database.getAllAsync(
      `SELECT r.*, b.billName, b.dueDate
       FROM reminders r
       LEFT JOIN bills b ON r.billId = b.id
       WHERE r.userId = ? AND r.status = 'Active'
       ORDER BY r.reminderDate ASC
       LIMIT ?;`,
      [userId, limit]
    );
    return results.map(r => ({ ...r }));
  } catch (err) {
    console.error("‚ùå getRemindersLocal error:", err);
    return [];
  }
};

export const deleteReminderLocal = async (userId, id) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `DELETE FROM reminders WHERE id = ? AND userId = ?;`,
      [id, userId]
    );
    console.log(`üóëÔ∏è Reminder ID ${id} deleted for user ${userId}`);
  } catch (err) {
    console.error("‚ùå deleteReminderLocal error:", err);
  }
};

export const checkDueBillsAndGenerateReminders = async (userId, showAlerts = true) => {
  try {
    const database = await getDatabase();
    const bills = await getBillsLocal(userId);
    if (!bills || bills.length === 0) return;

    const today = new Date();
    const todayStr = today.toISOString().split("T")[0];
    const todayStart = new Date(todayStr + "T00:00:00");

    const reminderMessages = [];

    for (const b of bills) {
      try {
        if (!b.dueDate) continue;

        const dueDateStr = b.dueDate;
        const due = new Date(dueDateStr + "T00:00:00");

        const msPerDay = 1000 * 60 * 60 * 24;
        const daysDiff = Math.floor((due - todayStart) / msPerDay);

        let newStatus = "Upcoming";
        if (daysDiff < 0) newStatus = "Overdue";
        else if (daysDiff <= 3) newStatus = "DueSoon";

        if (newStatus !== b.status) {
          await updateBillLocal(userId, b.id, { status: newStatus });
        }

        let reminderDate = null;
        if (newStatus === "Overdue") reminderDate = todayStr;
        else if (newStatus === "DueSoon") reminderDate = dueDateStr;

        if ((newStatus === "Overdue" || newStatus === "DueSoon") && reminderDate && showAlerts) {
          const existing = await database.getFirstAsync(
            `SELECT id FROM reminders WHERE billId = ? AND reminderDate = ? AND status = 'Active' LIMIT 1;`,
            [b.id, reminderDate]
          );

          if (!existing) {
            const message =
              newStatus === "Overdue"
                ? `‚ùó ${b.billName} is overdue.`
                : `‚è≥ ${b.billName} is due in ${Math.max(0, daysDiff)} day(s).`;

            const createdAtDate = todayStr;

            await database.runAsync(
              `INSERT INTO reminders (billId, userId, message, reminderDate, status, createdAt)
               VALUES (?, ?, ?, ?, 'Active', ?);`,
              [b.id, userId, message, reminderDate, createdAtDate]
            );

            reminderMessages.push(message);
          }
        }
      } catch (innerErr) {
        console.error("Error processing bill:", b.id, innerErr);
      }
    }

    if (reminderMessages.length > 0 && showAlerts) {
      const alertText = reminderMessages.join("\n");

      Alert.alert(
        "üîî Bill Reminders",
        alertText + "\n\nPlease settle them soon.",
        [{ text: "OK" }]
      );
    }

  } catch (err) {
    console.error("‚ùå checkDueBillsAndGenerateReminders error:", err);
  }
};

export const getMonthlyDebtSum = async (userId) => {
  try {
    const database = await getDatabase();
    const rows = await database.getAllAsync(
      `SELECT amount, category FROM bills WHERE userId = ? AND status != 'Paid';`,
      [userId]
    );
    let sum = 0;
    for (const r of rows) {
      const cat = (r.category || "").toLowerCase();
      if (cat.includes("debt") || cat.includes("credit") || cat.includes("loan") || cat.includes("debt")) {
        sum += parseFloat(r.amount || 0);
      }
    }
    return sum;
  } catch (err) {
    console.error("‚ùå getMonthlyDebtSum error:", err);
    return 0;
  }
};

// ------------------- AUTO TAG PREDICTOR FUNCTIONS -------------------
export async function getUserTag(userId, payee) {
  const database = await getDatabase();
  const norm = normalize(payee);
  console.log("üîç getUserTag DEBUG:", {
    userId,
    payee,
    normalized: norm,
    normalizedLength: norm.length
  });

  try {
    const row = await database.getFirstAsync(
      `SELECT tag, confidence, count 
       FROM predictor_cache 
       WHERE payee_normalized = ? AND user_id = ?
       LIMIT 1;`,
      [norm, userId]
    );

    console.log("üîç getUserTag RESULT:", row);
    return row ?? null;
  } catch (err) {
    console.error("‚ùå getUserTag error:", err);
    return null;
  }
}

export async function saveUserTag(userId, payee, tag, is_custom = 0) {
  const database = await getDatabase();
  const norm = normalize(payee);
  const ts = Math.floor(Date.now() / 1000);

  try {
    const existing = await database.getFirstAsync(
      `SELECT * FROM predictor_cache WHERE payee_normalized = ? AND user_id = ?;`,
      [norm, userId]
    );

    if (existing) {
      await database.runAsync(
        `UPDATE predictor_cache 
         SET tag = ?, 
             count = count + 1,
             confidence = MIN(1.0, confidence + 0.05),
             last_used = ?,
             is_custom = ?
         WHERE payee_normalized = ? AND user_id = ?;`,
        [tag, ts, is_custom, norm, userId]
      );
      console.log(`‚úÖ Updated tag for "${payee}" -> "${tag}"`);
    } else {
      await database.runAsync(
        `INSERT INTO predictor_cache 
         (user_id, payee_normalized, tag, count, confidence, last_used, is_custom)
         VALUES (?, ?, ?, 1, 1.0, ?, ?);`,
        [userId, norm, tag, ts, is_custom]
      );
      console.log(`‚úÖ Saved new tag for "${payee}" -> "${tag}"`);
    }

    return true;
  } catch (err) {
    console.error("saveUserTag error:", err);
    return false;
  }
}

export async function getUserPredictions(userId) {
  try {
    const database = await getDatabase();
    const rows = await database.getAllAsync(
      `SELECT * FROM predictor_cache WHERE user_id = ? ORDER BY last_used DESC;`,
      [userId]
    );
    return rows;
  } catch (err) {
    console.error("getUserPredictions error:", err);
    return [];
  }
}

export async function clearUserPredictions(userId) {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `DELETE FROM predictor_cache WHERE user_id = ?;`,
      [userId]
    );
    console.log(`‚úÖ Cleared predictions for user ${userId}`);
    return true;
  } catch (err) {
    console.error("clearUserPredictions error:", err);
    return false;
  }
}

// Normalize function
function normalize(payee) {
  if (!payee) return '';
  return payee
    .toLowerCase()
    .trim()
    .replace(/[^\w\s]/g, '')
    .replace(/\s+/g, ' ');
}

// ------------------- SAVING METHODS & ACCOUNTS -------------------

// Initialize default saving methods
export const initDefaultSavingMethods = async (userId) => {
  const database = await getDatabase();
  const defaultMethods = [
    { method_name: "Fixed Deposit", method_type: "bank", risk_level: 1, liquidity_level: 3, expected_return: 3.2, color_code: "#4CAF50", icon_name: "üè¶", is_default: 1 },
    { method_name: "Gold Bar", method_type: "physical", risk_level: 2, liquidity_level: 2, expected_return: 5.0, color_code: "#FFD700", icon_name: "ü•á", is_default: 1 },
    { method_name: "Unit Trust", method_type: "investment", risk_level: 3, liquidity_level: 4, expected_return: 8.0, color_code: "#2196F3", icon_name: "üìà", is_default: 1 },
    { method_name: "Stocks", method_type: "investment", risk_level: 4, liquidity_level: 5, expected_return: 12.0, color_code: "#FF9800", icon_name: "üìä", is_default: 1 },
    { method_name: "Cash", method_type: "cash", risk_level: 1, liquidity_level: 5, expected_return: 0.0, color_code: "#9E9E9E", icon_name: "üíµ", is_default: 1 },
    { method_name: "Digital Gold", method_type: "digital", risk_level: 2, liquidity_level: 5, expected_return: 6.0, color_code: "#FFC107", icon_name: "üì±", is_default: 1 }
  ];

  for (const method of defaultMethods) {
    await database.runAsync(
      `INSERT OR IGNORE INTO saving_methods 
       (userId, method_name, method_type, risk_level, liquidity_level, expected_return, color_code, icon_name)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [userId, method.method_name, method.method_type, method.risk_level,
        method.liquidity_level, method.expected_return, method.color_code, method.icon_name]
    );
  }
  console.log("‚úÖ Default saving methods initialized");
};

// Create saving account
export const addSavingAccount = async (userId, method_id, account_name, institution_name, account_number, interest_rate, maturity_date, notes = "") => {
  const database = await getDatabase();
  await database.runAsync(
    `INSERT INTO saving_accounts 
     (userId, method_id, account_name, institution_name, account_number, interest_rate, maturity_date, notes)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
    [userId, method_id, account_name, institution_name, account_number, interest_rate, maturity_date, notes]
  );
  console.log(`‚úÖ Saving account '${account_name}' added for user ${userId}`);
};

// Get saving methods
export const getSavingMethods = async (userId) => {
  const database = await getDatabase();
  return await database.getAllAsync(
    `SELECT * FROM saving_methods WHERE userId = ? ORDER BY method_name ASC;`,
    [userId]
  );
};

// Get saving accounts
export const getSavingAccounts = async (userId) => {
  const database = await getDatabase();
  return await database.getAllAsync(
    `SELECT sa.*, sm.method_name, sm.icon_name, sm.color_code
     FROM saving_accounts sa
     JOIN saving_methods sm ON sa.method_id = sm.id
     WHERE sa.userId = ? ORDER BY sa.account_name ASC;`,
    [userId]
  );
};
export const getAllocationByTransaction = async (userId, transactionId) => {
  const database = await getDatabase();
  return await database.getFirstAsync(
    `SELECT * FROM goal_fund_allocations 
     WHERE userId = ? AND transaction_id = ? 
     LIMIT 1`,
    [userId, transactionId]
  );
};


export const updateSavingAccountBalance = async (userId, accountId, delta) => {
  const database = await getDatabase();
  await database.runAsync(
    `UPDATE saving_accounts
     SET current_balance = current_balance + ?
     WHERE id = ? AND userId = ?`,
    [delta, accountId, userId]
  );
};


// ------------------- GOAL FUND ALLOCATION -------------------
export const addSavingMethod = async (userId, methodData) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `INSERT INTO saving_methods 
       (userId, method_name, method_type, risk_level, liquidity_level, 
        expected_return, color_code, icon_name, is_default)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        userId,
        methodData.method_name,
        methodData.method_type,
        methodData.risk_level,
        methodData.liquidity_level,
        methodData.expected_return,
        methodData.color_code,
        methodData.icon_name,
        methodData.is_default || 0
      ]
    );
    console.log(`‚úÖ Saving method '${methodData.method_name}' added`);
    return true;
  } catch (error) {
    console.error("‚ùå addSavingMethod error:", error);
    return false;
  }
};

export const updateSavingMethod = async (userId, methodId, methodData) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `UPDATE saving_methods 
       SET method_name = ?, method_type = ?, risk_level = ?, liquidity_level = ?,
           expected_return = ?, color_code = ?, icon_name = ?
       WHERE id = ? AND userId = ? AND is_default = 0`,
      [
        methodData.method_name,
        methodData.method_type,
        methodData.risk_level,
        methodData.liquidity_level,
        methodData.expected_return,
        methodData.color_code,
        methodData.icon_name,
        methodId,
        userId
      ]
    );
    console.log(`‚úÖ Saving method ${methodId} updated`);
    return true;
  } catch (error) {
    console.error("‚ùå updateSavingMethod error:", error);
    return false;
  }
};

export const deleteSavingMethod = async (userId, methodId) => {
  try {
    const database = await getDatabase();
    const accounts = await database.getAllAsync(
      `SELECT id FROM saving_accounts WHERE method_id = ? AND userId = ?`,
      [methodId, userId]
    );

    if (accounts.length > 0) {
      throw new Error("Cannot delete method with existing accounts");
    }

    await database.runAsync(
      `DELETE FROM saving_methods WHERE id = ? AND userId = ? AND is_default = 0`,
      [methodId, userId]
    );
    console.log(`‚úÖ Saving method ${methodId} deleted`);
    return true;
  } catch (error) {
    console.error("‚ùå deleteSavingMethod error:", error);
    throw error;
  }
};

export const allocateFundToGoal = async (userId, goalId, account_id, allocated_amount, allocation_date, transaction_id, maturity_date, notes = "", method_id) => {
  try {
    const database = await getDatabase();
    const account = await database.getFirstAsync(
      `SELECT interest_rate FROM saving_accounts WHERE id = ? AND userId = ?`,
      [account_id, userId]
    );

    const interest_rate = account?.interest_rate || 0;
    const expected_value = allocated_amount * (1 + interest_rate / 100);

    await database.runAsync(
      `INSERT INTO goal_fund_allocations 
       (userId, goalId, account_id, method_id, allocated_amount, allocation_date, transaction_id, maturity_date, current_value, expected_value, notes)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [userId, goalId, account_id, method_id, allocated_amount, allocation_date, transaction_id,
        maturity_date, allocated_amount, expected_value, notes]
    );

    await database.runAsync(
      `UPDATE saving_accounts SET current_balance = current_balance + ? WHERE id = ? AND userId = ?`,
      [allocated_amount, account_id, userId]
    );

    await recalculateGoalCurrentAmount(userId, goalId);

    console.log(`‚úÖ Fund allocated to goal: ${allocated_amount} to account ${account_id}`);
  } catch (error) {
    console.error("‚ùå allocateFundToGoal error:", error);
    throw error;
  }
};

export const getGoalFundAllocations = async (userId, goalId) => {
  const database = await getDatabase();
  return await database.getAllAsync(
    `SELECT gfa.*,
       sa.account_name, sa.institution_name, sa.interest_rate,
       sm.method_name, sm.icon_name, sm.color_code
      FROM goal_fund_allocations gfa
      JOIN saving_accounts sa ON gfa.account_id = sa.id
      JOIN saving_methods sm ON gfa.method_id = sm.id
      WHERE gfa.userId = ? AND gfa.goalId = ? AND gfa.status IN ('active', 'withdrawal_requested')
      ORDER BY gfa.allocation_date DESC;`,
    [userId, goalId]
  );
};

export const deleteGoalAllocation = async (userId, allocationId) => {
  const database = await getDatabase();
  await database.runAsync(
    `DELETE FROM goal_fund_allocations WHERE id = ? AND userId = ?`,
    [allocationId, userId]
  );
};


// ------------------- WITHDRAWAL MANAGEMENT -------------------

export const createWithdrawalRecord = async (userId, goalId, allocation_id, withdrawal_amount, principal_amount, interest_amount, notes = "") => {
  try {
    const database = await getDatabase();
    const result = await database.runAsync(
      `INSERT INTO withdrawal_records 
       (userId, goalId, allocation_id, withdrawal_amount, principal_amount, interest_amount, notes)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [userId, goalId, allocation_id, withdrawal_amount, principal_amount, interest_amount, notes]
    );

    // Update allocation status to withdrawal_requested
    await database.runAsync(
      `UPDATE goal_fund_allocations SET status = 'withdrawal_requested' WHERE id = ? AND userId = ?`,
      [allocation_id, userId]
    );

    console.log(`‚úÖ Withdrawal record created for allocation ${allocation_id}`);
    return { success: true, id: result.insertId };
  } catch (error) {
    console.error("‚ùå createWithdrawalRecord error:", error);
    return { success: false, error: error.message };
  }
};

 export const deleteWithdrawalHistory = async (userId, withdrawalId) => {
    const database = await getDatabase();
    await database.runAsync(
      `DELETE FROM withdrawal_records
     WHERE id = ? AND userId = ?`,
      [withdrawalId, userId]
    );
  };


export const confirmWithdrawal = async (userId, withdrawal_id, confirmed_amount) => {
  try {
    const database = await getDatabase();
    console.log("üîÑ Starting withdrawal confirmation...", { userId, withdrawal_id, confirmed_amount });


    if (!withdrawal_id || !confirmed_amount || confirmed_amount <= 0) {
      throw new Error("Invalid withdrawal confirmation parameters");
    }

    const withdrawal = await database.getFirstAsync(
      `SELECT * FROM withdrawal_records WHERE id = ? AND userId = ? AND status = 'pending'`,
      [withdrawal_id, userId]
    );

    if (!withdrawal) {
      throw new Error("Withdrawal record not found or already processed");
    }

    console.log("üìã Withdrawal details:", {
      allocation_id: withdrawal.allocation_id,
      goalId: withdrawal.goalId,
      principal: withdrawal.principal_amount,
      interest: withdrawal.interest_amount
    });


    await database.execAsync('BEGIN TRANSACTION');

    try {
      // 1. Update withdrawal record status
      console.log("1. Updating withdrawal record status...");
      const updateResult = await database.runAsync(
        `UPDATE withdrawal_records 
         SET status = 'completed', confirmed_amount = ?, confirmed_date = datetime('now')
         WHERE id = ? AND userId = ?`,
        [confirmed_amount, withdrawal_id, userId]
      );

      if (updateResult.rowsAffected === 0) {
        throw new Error("Failed to update withdrawal record");
      }

      // 2. Update allocation status
      console.log("2. Updating fund allocation status...");
      const allocationResult = await database.runAsync(
        `UPDATE goal_fund_allocations SET status = 'withdrawn' WHERE id = ? AND userId = ?`,
        [withdrawal.allocation_id, userId]
      );

      if (allocationResult.rowsAffected === 0) {
        throw new Error("Failed to update fund allocation status");
      }

      // 3. Update account balance
      console.log("3. Updating account balance...");
      const accountId = await getAllocationAccountId(withdrawal.allocation_id);
      if (!accountId) {
        throw new Error("Could not find account for allocation");
      }

      const accountResult = await database.runAsync(
        `UPDATE saving_accounts SET current_balance = current_balance + ? WHERE id = ? AND userId = ?`,
        [confirmed_amount, accountId, userId]
      );

      if (accountResult.rowsAffected === 0) {
        throw new Error("Failed to update account balance");
      }

      // 4. Mark original expense as settled (NOTE: Requires schema change to add status field to expenses table)
      // TODO: Add status field to expenses table and update: UPDATE expenses SET status = 'settled' WHERE id = ? AND userId = ?

      // 5. Update user summary - use settlement formula
      console.log("5. Updating user summary with settlement formula...");
      const A = withdrawal.principal_amount; // original allocated amount
      const W = confirmed_amount; // confirmed withdrawal amount
      const D = W - A; // difference

      console.log(`   Settlement: A=${A}, W=${W}, D=${D}`);

      // ‚úÖ Correct: settlement only
      await applyWithdrawalSettlementToUserSummary(
        userId,
        withdrawal.principal_amount,
        confirmed_amount
      );
      // Commit transaction
      await database.execAsync('COMMIT');

      console.log(`‚úÖ Withdrawal confirmed successfully: ${withdrawal_id}, amount: ${confirmed_amount}`);

      return {
        success: true,
        withdrawal_id: withdrawal_id,
        confirmed_amount: confirmed_amount,
        principal: withdrawal.principal_amount,
        difference: D
      };

    } catch (error) {
      // Rollback transaction
      await database.execAsync('ROLLBACK');
      console.error("‚ùå Transaction failed, rolling back...", error);
      throw error;
    }

  } catch (error) {
    console.error("‚ùå confirmWithdrawal error:", error);
    throw error;
  }
};



// Cancel withdrawal record
export const cancelWithdrawal = async (userId, withdrawal_id) => {
  const database = await getDatabase();
  // Get the allocation_id first
  const withdrawal = await database.getFirstAsync(
    `SELECT allocation_id FROM withdrawal_records WHERE id = ? AND userId = ?`,
    [withdrawal_id, userId]
  );

  if (withdrawal) {
    // Update withdrawal status
    await database.runAsync(
      `UPDATE withdrawal_records SET status = 'cancelled' WHERE id = ? AND userId = ?`,
      [withdrawal_id, userId]
    );

    // Reset allocation status back to active
    await database.runAsync(
      `UPDATE goal_fund_allocations SET status = 'active' WHERE id = ? AND userId = ?`,
      [withdrawal.allocation_id, userId]
    );

    console.log(`‚úÖ Withdrawal cancelled: ${withdrawal_id}`);
  }
};

// Get pending withdrawal records
export const getPendingWithdrawals = async (userId) => {
  const database = await getDatabase();
  return await database.getAllAsync(
    `SELECT wr.*, g.goalName, sa.account_name, sa.institution_name, sm.method_name, gfa.current_value
     FROM withdrawal_records wr
     JOIN goals g ON wr.goalId = g.id
     JOIN goal_fund_allocations gfa ON wr.allocation_id = gfa.id
     JOIN saving_accounts sa ON gfa.account_id = sa.id
     JOIN saving_methods sm ON sa.method_id = sm.id
     WHERE wr.userId = ? AND wr.status = 'pending'
     ORDER BY wr.withdrawal_date DESC;`,
    [userId]
  );
};

// Get all withdrawal records
export const getAllWithdrawals = async (userId) => {
  const database = await getDatabase();
  return await database.getAllAsync(
    `SELECT wr.*, g.goalName, sa.account_name, sa.institution_name, sm.method_name, gfa.current_value
     FROM withdrawal_records wr
     JOIN goals g ON wr.goalId = g.id
     JOIN goal_fund_allocations gfa ON wr.allocation_id = gfa.id
     JOIN saving_accounts sa ON gfa.account_id = sa.id
     JOIN saving_methods sm ON sa.method_id = sm.id
     WHERE wr.userId = ?
     ORDER BY wr.withdrawal_date DESC;`,
    [userId]
  );
};

export const hasPendingWithdrawal = async (userId, allocationId) => {
  try {
    const database = await getDatabase();
    const result = await database.getFirstAsync(
      `SELECT COUNT(*) as count FROM withdrawal_records 
       WHERE userId = ? AND allocation_id = ? AND status = 'pending'`,
      [userId, allocationId]
    );
    return result.count > 0;
  } catch (error) {
    console.error("‚ùå hasPendingWithdrawal error:", error);
    return false;
  }
};

export const applyWithdrawalSettlementToUserSummary = async (
  userId,
  principal,
  confirmedAmount
) => {
  const A = Number(principal);
  const W = Number(confirmedAmount);
  const D = W - A;

  const database = await getDatabase();

  // Step 1: reverse original allocation expense
  await database.runAsync(
    `
    UPDATE user_summary
    SET total_expense = total_expense - ?,
        total_balance = total_balance + ?
    WHERE userId = ?
    `,
    [A, A, userId]
  );

  // Step 2: apply difference
  if (D > 0) {
    await database.runAsync(
      `
      UPDATE user_summary
      SET total_income = total_income + ?,
          total_balance = total_balance + ?
      WHERE userId = ?
      `,
      [D, D, userId]
    );
  } else if (D < 0) {
    const loss = Math.abs(D);
    await database.runAsync(
      `
      UPDATE user_summary
      SET total_expense = total_expense + ?,
          total_balance = total_balance - ?
      WHERE userId = ?
      `,
      [loss, loss, userId]
    );
  }
};


// Helper function: Get allocated account ID
const getAllocationAccountId = async (allocation_id) => {
  const database = await getDatabase();
  const result = await database.getFirstAsync(
    `SELECT account_id FROM goal_fund_allocations WHERE id = ?`,
    [allocation_id]
  );
  return result?.account_id;
};

export const updateAllocationAfterWithdraw = async (
  userId,
  allocationId,
  withdrawAmount
) => {
  try {
    const database = await getDatabase();
    // 1. Get original allocation data
    const alloc = await database.getFirstAsync(
      `SELECT allocated_amount, expected_value, account_id, goalId
       FROM goal_fund_allocations
       WHERE id = ? AND userId = ?`,
      [allocationId, userId]
    );

    if (!alloc) throw new Error("Allocation not found");

    // 2. Get interest rate of this account
    const account = await database.getFirstAsync(
      `SELECT interest_rate FROM saving_accounts WHERE id = ? AND userId = ?`,
      [alloc.account_id, userId]
    );

    if (!account) throw new Error("Account not found");

    const r = account.interest_rate / 100;

    // 3. Reverse interest calculation
    const expected_new = alloc.expected_value - withdrawAmount;

    if (expected_new < 0) throw new Error("Withdraw amount exceeds total balance");

    const allocated_new = expected_new / (1 + r);

    // 4. Update new allocated & expected values
    await database.runAsync(
      `UPDATE goal_fund_allocations
       SET allocated_amount = ?, expected_value = ?, current_value = ?
       WHERE id = ? AND userId = ?`,
      [allocated_new, expected_new, expected_new, allocationId, userId]
    );

    // 5. Increase available saving account balance
    await database.runAsync(
      `UPDATE saving_accounts
       SET current_balance = current_balance + ?
       WHERE id = ? AND userId = ?`,
      [withdrawAmount, alloc.account_id, userId]
    );

    // 6. Recalculate goal total
    await recalculateGoalCurrentAmount(userId, alloc.goalId);

    return true;

  } catch (err) {
    console.error("‚ùå updateAllocationAfterWithdraw error:", err);
    throw err;
  }
};


// ------------------- MATURITY MANAGEMENT -------------------

// Check expired allocations
export const checkMaturedAllocations = async (userId) => {
  const database = await getDatabase();
  const today = new Date().toISOString().split('T')[0];

  const maturedAllocations = await database.getAllAsync(
    `SELECT gfa.*, g.goalName, sa.account_name, sa.institution_name
     FROM goal_fund_allocations gfa
     JOIN goals g ON gfa.goalId = g.id
     JOIN saving_accounts sa ON gfa.account_id = sa.id
     WHERE gfa.userId = ? AND gfa.status = 'active' AND gfa.maturity_date <= ?`,
    [userId, today]
  );

  return maturedAllocations;
};

// Automatically process expired allocations
export const processMaturedAllocations = async (userId) => {
  try {
    const database = await getDatabase();
    const maturedAllocations = await checkMaturedAllocations(userId);

    for (const allocation of maturedAllocations) {
      // Calculate interest
      const interest_amount = allocation.current_value - allocation.allocated_amount;

      // Create withdrawal record (auto confirm)
      await createWithdrawalRecord(
        userId,
        allocation.goalId,
        allocation.id,
        allocation.current_value,
        allocation.allocated_amount,
        interest_amount,
        "Auto-processed upon maturity"
      );

      // Auto confirm withdrawal
      const withdrawal = await database.getFirstAsync(
        `SELECT id FROM withdrawal_records 
         WHERE allocation_id = ? AND status = 'pending' 
         ORDER BY id DESC LIMIT 1`,
        [allocation.id]
      );

      if (withdrawal) {
        await confirmWithdrawal(userId, withdrawal.id, allocation.current_value);
      }

      console.log(`‚úÖ Matured allocation processed: ${allocation.id}`);
    }

    return maturedAllocations.length;
  } catch (error) {
    console.error("‚ùå processMaturedAllocations error:", error);
    throw error;
  }
};

// ------------------- VALUE UPDATES -------------------

// Manually update allocation current value
export const updateAllocationCurrentValue = async (userId, allocation_id, new_current_value) => {
  const database = await getDatabase();
  await database.runAsync(
    `UPDATE goal_fund_allocations SET current_value = ? WHERE id = ? AND userId = ?`,
    [new_current_value, allocation_id, userId]
  );

  // Recalculate goal total amount
  await recalculateGoalCurrentAmount(userId, await database.getFirstAsync(
    `SELECT goalId FROM goal_fund_allocations WHERE id = ?`, [allocation_id]
  ).goalId);
};

// Recalculate goal current amount
const recalculateGoalCurrentAmount = async (userId, goalId) => {
  const database = await getDatabase();
  const allocations = await database.getAllAsync(
    `SELECT current_value FROM goal_fund_allocations 
     WHERE userId = ? AND goalId = ? AND status = 'active'`,
    [userId, goalId]
  );

  const totalCurrentValue = allocations.reduce((sum, alloc) => sum + (alloc.current_value || 0), 0);

  await database.runAsync(
    `UPDATE goals SET currentAmount = ? WHERE id = ? AND userId = ?`,
    [totalCurrentValue, goalId, userId]
  );
};

export const hasSnapshotForMonth = async (userId, month) => {
  const database = await getDatabase();
  const row = await database.getFirstAsync(
    `SELECT id FROM income_snapshots WHERE userId = ? AND month = ? LIMIT 1`,
    [userId, month]
  );
  return !!row;
};


export const saveMonthlyIncomeSnapshot = async (userId, date) => {
  try {
    const database = await getDatabase();
    const month = date.slice(0, 7); // YYYY-MM

    // Calculate current month total income (not cumulative)
    const result = await database.getFirstAsync(
      `SELECT SUM(amount) AS monthlyIncome
       FROM expenses
       WHERE userId = ?
       AND typeLabel = 'income'
       AND strftime('%Y-%m', date) = ?`,
      [userId, month]
    );

    const monthlyIncome = result?.monthlyIncome ? parseFloat(result.monthlyIncome) : 0;

    // Save to snapshots
    await database.runAsync(
      `INSERT OR REPLACE INTO income_snapshots (userId, month, income_amount)
       VALUES (?, ?, ?)`,
      [userId, month, monthlyIncome]
    );

    console.log(`üìå Snapshot saved for ${month}: RM${monthlyIncome}`);
  } catch (err) {
    console.error("‚ùå saveMonthlyIncomeSnapshot error:", err);
  }
};


export const getIncomeGrowthRate = async (userId) => {
  const database = await getDatabase();
  const rows = await database.getAllAsync(
    `SELECT month, income_amount 
     FROM income_snapshots 
     WHERE userId = ?
     ORDER BY month DESC 
     LIMIT 2`,
    [userId]
  );

  if (rows.length < 2) {
    return { rate: 0, current: rows[0]?.income_amount || 0, previous: 0 };
  }

  const current = rows[0].income_amount;
  const previous = rows[1].income_amount;

  if (previous === 0) {
    return { rate: 1, current, previous }; // 100% growth if previous was 0
  }

  const rate = (current - previous) / previous;

  return { rate, current, previous };
};

export const recalculateMonthlyIncomeSnapshot = async (userId, date) => {
  const database = await getDatabase();
  const month = date.slice(0, 7);

  const result = await database.getFirstAsync(
    `SELECT SUM(amount) AS total
     FROM expenses
     WHERE userId = ?
     AND typeLabel = 'income'
     AND strftime('%Y-%m', date) = ?`,
    [userId, month]
  );

  const income = result?.total ? parseFloat(result.total) : 0;

  await database.runAsync(
    `INSERT OR REPLACE INTO income_snapshots (userId, month, income_amount)
     VALUES (?, ?, ?)`,
    [userId, month, income]
  );

  console.log("üìå Snapshot recalculated for", month, ": RM", income);
};

export const getCurrentMonthSnapshotIncome = async (userId) => {
  const database = await getDatabase();
  const now = new Date();
  const month = now.toISOString().slice(0, 7);

  const row = await database.getFirstAsync(
    `SELECT income_amount 
     FROM income_snapshots
     WHERE userId = ? AND month = ?
     LIMIT 1`,
    [userId, month]
  );

  return row?.income_amount || 0;
};

export const resetIncomeSnapshots = async (userId) => {
  try {
    const database = await getDatabase();
    await database.runAsync(
      `DELETE FROM income_snapshots WHERE userId = ?`,
      [userId]
    );
    console.log("üóëÔ∏è Income snapshots reset");
  } catch (err) {
    console.error("‚ùå resetIncomeSnapshots error:", err);
  }
};

// -------------------- DIRECT USER SUMMARY UPDATE --------------------
export const updateUserSummaryDirect = async (userId, totalIncome, totalExpense, totalBalance) => {
  try {
    const database = await getDatabase();
    const results = await database.runAsync(
      `UPDATE user_summary SET total_income = ?, total_expense = ?, total_balance = ? WHERE userId = ?`,
      [totalIncome, totalExpense, totalBalance, userId]
    );
    console.log(`‚úÖ Direct summary update: Income ${totalIncome}, Expense ${totalExpense}, Balance ${totalBalance}`);
    return results;
  } catch (error) {
    console.error(`‚ùå Error updating summary directly:`, error);
    throw error;
  }
};

// ------------------- DANGER ZONE -------------------
export const resetAllDatabaseData = async () => {
  try {
    const database = await getDatabase();

    await database.execAsync("BEGIN TRANSACTION");

    const tables = [
      "expenses",
      "bills",
      "reminders",
      "goals",
      "goal_fund_allocations",
      "withdrawal_records",
      "tags",
      "eventTags",
      "activeEventTags",
      "saving_accounts",
      "saving_methods",
      "user_summary",
      "income_snapshots",
      "predictor_cache"
    ];

    for (const table of tables) {
      await database.runAsync(`DELETE FROM ${table};`);
    }

    await database.execAsync("COMMIT");

    console.log("üß® All database data has been reset");
    return true;
  } catch (error) {
    await database.execAsync("ROLLBACK");
    console.error("‚ùå resetAllDatabaseData error:", error);
    throw error;
  }
};

